
==================== FINAL INTERFACE ====================
2020-05-15 16:57:04.0574142 UTC

interface main:ChessBoard 8065
  interface hash: bcf4829113e8a64563358fab8fb6b23b
  ABI hash: e99d665849fa1dcac8a64ec03d28fea7
  export-list hash: 13b42b22814f31f9b42801af93b414ca
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 60a29d9b0283457aa1b23a7b8469000f
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  ChessBoard.baseRow
  ChessBoard.blackPlayer
  ChessBoard.changeBoard
  ChessBoard.checkPawnPromotion
  ChessBoard.checkPiece
  ChessBoard.colSep
  ChessBoard.colorPiece
  ChessBoard.cycleBoardCheck
  ChessBoard.cycleMoveCheck
  ChessBoard.emptyRow
  ChessBoard.firstPiece
  ChessBoard.fromPieceToChessPiece
  ChessBoard.fromPieceToColor
  ChessBoard.game
  ChessBoard.getKingInBoard
  ChessBoard.getKingLocation
  ChessBoard.getNextCol
  ChessBoard.getNextRow
  ChessBoard.isAnyBishopMove
  ChessBoard.isAnyKingMove
  ChessBoard.isAnyKnightMove
  ChessBoard.isAnyMove
  ChessBoard.isAnyMoveRecurse
  ChessBoard.isAnyPawnMove
  ChessBoard.isAnyQueenMove
  ChessBoard.isAnyRookMove
  ChessBoard.isClearPath
  ChessBoard.isEnemyPiece
  ChessBoard.isGameOver
  ChessBoard.isKingInCheck
  ChessBoard.isKingInDiagCheck
  ChessBoard.isKingInKingCheck
  ChessBoard.isKingInKnightCheck
  ChessBoard.isKingInPawnCheck
  ChessBoard.isKingInStraightCheck
  ChessBoard.isKingLeftInCheck
  ChessBoard.isOpen
  ChessBoard.isValidBishopMove
  ChessBoard.isValidBishopMovement
  ChessBoard.isValidKingMove
  ChessBoard.isValidKingMovement
  ChessBoard.isValidKnightMove
  ChessBoard.isValidKnightMovement
  ChessBoard.isValidMove
  ChessBoard.isValidMoveColor
  ChessBoard.isValidMovement
  ChessBoard.isValidMovementPiece
  ChessBoard.isValidPawnAttack
  ChessBoard.isValidPawnMove
  ChessBoard.isValidPawnMovement
  ChessBoard.isValidPlayerMove
  ChessBoard.isValidQueenMove
  ChessBoard.isValidQueenMovement
  ChessBoard.isValidRookMove
  ChessBoard.isValidRookMovement
  ChessBoard.location
  ChessBoard.mkDiagLocs
  ChessBoard.movePiece
  ChessBoard.notColor
  ChessBoard.pawnRow
  ChessBoard.pieceValue
  ChessBoard.printBoard
  ChessBoard.printCol
  ChessBoard.printMaybePiece
  ChessBoard.printPiece
  ChessBoard.printPlayerScore
  ChessBoard.printRow
  ChessBoard.printScore
  ChessBoard.promotePawn
  ChessBoard.promotePawnBoard
  ChessBoard.removePiece
  ChessBoard.rowSep
  ChessBoard.startBoard
  ChessBoard.swapLoc
  ChessBoard.turnToColor
  ChessBoard.updateActive
  ChessBoard.updateBoard
  ChessBoard.updateCaptured
  ChessBoard.updateGameBoard
  ChessBoard.updateGamePlayers
  ChessBoard.updatePlayerName
  ChessBoard.updateScore
  ChessBoard.whitePlayer
  ChessBoard.Board
  ChessBoard.ChessPiece{ChessBoard.Bishop ChessBoard.King ChessBoard.Knight ChessBoard.Pawn ChessBoard.Queen ChessBoard.Rook}
  ChessBoard.ColLoc
  ChessBoard.Color{ChessBoard.Black ChessBoard.White}
  ChessBoard.Direction{ChessBoard.Backward ChessBoard.DiagBL ChessBoard.DiagBR ChessBoard.DiagFL ChessBoard.DiagFR ChessBoard.Forward ChessBoard.Leftt ChessBoard.Rightt}
  ChessBoard.Game{ChessBoard.Game gameBoard gamePlayer1 gamePlayer2}
  ChessBoard.GameOver{ChessBoard.CheckMate ChessBoard.StaleMate ChessBoard.Unfinished}
  ChessBoard.Location{ChessBoard.Location}
  ChessBoard.Piece{ChessBoard.Piece}
  ChessBoard.Pieces
  ChessBoard.Player{ChessBoard.Player active captured name playerColor score}
  ChessBoard.Row
  ChessBoard.RowLoc
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Foldable bdeac546b12282c8986759606b9295a5
import  -/  base-4.12.0.0:Data.Functor e667059569e58719cf8eee08191ebb1e
import  -/  base-4.12.0.0:Data.List 6c60559263db7cf0f22549b9673785b9
import  -/  base-4.12.0.0:Data.Maybe d07d5847f427040b05c592631bb0d4af
import  -/  base-4.12.0.0:Data.OldList 9c79c2259344fa5285ac49797d9c5db1
import  -/  base-4.12.0.0:Data.Tuple 3bf97d65c8e783335a95628f6e4f6f75
import  -/  base-4.12.0.0:GHC.Base fbe365a916ebeeeb4bc1f895dbe83e42
import  -/  base-4.12.0.0:GHC.List bb56c56a8dc21963b5824914872db158
import  -/  base-4.12.0.0:GHC.Num 8203d3fee487126cffd5e55ba5d0e8c3
import  -/  base-4.12.0.0:GHC.Show fa6032f3f820e8e8ec87b97bdca4e160
import  -/  base-4.12.0.0:Prelude 80c668cb99fbafebd524c5e897f8c982
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
a9339aa10bc82e16fb147d7654bbb4ff
  $fEqChessPiece :: GHC.Classes.Eq ChessBoard.ChessPiece
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.ChessPiece
                  ChessBoard.$fEqChessPiece_$c==
                  ChessBoard.$fEqChessPiece_$c/= -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fEqChessPiece_$c/= ::
    ChessBoard.ChessPiece -> ChessBoard.ChessPiece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.ChessPiece) (y :: ChessBoard.ChessPiece) ->
                 case x2 of wild {
                   ChessBoard.Pawn
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Pawn -> GHC.Types.False }
                   ChessBoard.Bishop
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Bishop -> GHC.Types.False }
                   ChessBoard.Knight
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Knight -> GHC.Types.False }
                   ChessBoard.Rook
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Rook -> GHC.Types.False }
                   ChessBoard.Queen
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Queen -> GHC.Types.False }
                   ChessBoard.King
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.King -> GHC.Types.False } }) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fEqChessPiece_$c== ::
    ChessBoard.ChessPiece -> ChessBoard.ChessPiece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: ChessBoard.ChessPiece)
                   (ds1 :: ChessBoard.ChessPiece) ->
                 case ds of wild {
                   ChessBoard.Pawn
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Pawn -> GHC.Types.True }
                   ChessBoard.Bishop
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Bishop -> GHC.Types.True }
                   ChessBoard.Knight
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Knight -> GHC.Types.True }
                   ChessBoard.Rook
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Rook -> GHC.Types.True }
                   ChessBoard.Queen
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Queen -> GHC.Types.True }
                   ChessBoard.King
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.King -> GHC.Types.True } }) -}
27801c70e04fd089bd52ac644edf6eba
  $fEqColor :: GHC.Classes.Eq ChessBoard.Color
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Color
                  ChessBoard.$fEqColor_$c==
                  ChessBoard.$fEqColor_$c/= -}
27801c70e04fd089bd52ac644edf6eba
  $fEqColor_$c/= ::
    ChessBoard.Color -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Color) (y :: ChessBoard.Color) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> case y of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> GHC.Types.True }
                   ChessBoard.White
                   -> case y of wild1 {
                        ChessBoard.Black -> GHC.Types.True
                        ChessBoard.White -> GHC.Types.False } }) -}
27801c70e04fd089bd52ac644edf6eba
  $fEqColor_$c== ::
    ChessBoard.Color -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: ChessBoard.Color) (ds1 :: ChessBoard.Color) ->
                 case ds of wild {
                   ChessBoard.Black
                   -> case ds1 of wild1 {
                        ChessBoard.Black -> GHC.Types.True
                        ChessBoard.White -> GHC.Types.False }
                   ChessBoard.White
                   -> case ds1 of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> GHC.Types.True } }) -}
8b7ec43a9e464f5e3a175896a8ca2ca2
  $fEqDirection :: GHC.Classes.Eq ChessBoard.Direction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Direction
                  ChessBoard.$fEqDirection_$c==
                  ChessBoard.$fEqDirection_$c/= -}
8b7ec43a9e464f5e3a175896a8ca2ca2
  $fEqDirection_$c/= ::
    ChessBoard.Direction -> ChessBoard.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Direction) (y :: ChessBoard.Direction) ->
                 case x2 of wild {
                   ChessBoard.Forward
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Forward -> GHC.Types.False }
                   ChessBoard.Backward
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Backward -> GHC.Types.False }
                   ChessBoard.Leftt
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Leftt -> GHC.Types.False }
                   ChessBoard.Rightt
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Rightt -> GHC.Types.False }
                   ChessBoard.DiagFR
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagFR -> GHC.Types.False }
                   ChessBoard.DiagBR
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagBR -> GHC.Types.False }
                   ChessBoard.DiagFL
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagFL -> GHC.Types.False }
                   ChessBoard.DiagBL
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.DiagBL -> GHC.Types.False } }) -}
8b7ec43a9e464f5e3a175896a8ca2ca2
  $fEqDirection_$c== ::
    ChessBoard.Direction -> ChessBoard.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: ChessBoard.Direction)
                   (ds1 :: ChessBoard.Direction) ->
                 case ds of wild {
                   ChessBoard.Forward
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Forward -> GHC.Types.True }
                   ChessBoard.Backward
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Backward -> GHC.Types.True }
                   ChessBoard.Leftt
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Leftt -> GHC.Types.True }
                   ChessBoard.Rightt
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Rightt -> GHC.Types.True }
                   ChessBoard.DiagFR
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagFR -> GHC.Types.True }
                   ChessBoard.DiagBR
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagBR -> GHC.Types.True }
                   ChessBoard.DiagFL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagFL -> GHC.Types.True }
                   ChessBoard.DiagBL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.DiagBL -> GHC.Types.True } }) -}
84ebeb4fb08dba347017ed67982bc062
  $fEqGameOver :: GHC.Classes.Eq ChessBoard.GameOver
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.GameOver
                  ChessBoard.$fEqGameOver_$c==
                  ChessBoard.$fEqGameOver_$c/= -}
84ebeb4fb08dba347017ed67982bc062
  $fEqGameOver_$c/= ::
    ChessBoard.GameOver -> ChessBoard.GameOver -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.GameOver) (y :: ChessBoard.GameOver) ->
                 case x2 of wild {
                   ChessBoard.CheckMate
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.CheckMate -> GHC.Types.False }
                   ChessBoard.StaleMate
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.StaleMate -> GHC.Types.False }
                   ChessBoard.Unfinished
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.Unfinished -> GHC.Types.False } }) -}
84ebeb4fb08dba347017ed67982bc062
  $fEqGameOver_$c== ::
    ChessBoard.GameOver -> ChessBoard.GameOver -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: ChessBoard.GameOver) (ds1 :: ChessBoard.GameOver) ->
                 case ds of wild {
                   ChessBoard.CheckMate
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.CheckMate -> GHC.Types.True }
                   ChessBoard.StaleMate
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.StaleMate -> GHC.Types.True }
                   ChessBoard.Unfinished
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.Unfinished -> GHC.Types.True } }) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fEqPiece :: GHC.Classes.Eq ChessBoard.Piece
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Piece
                  ChessBoard.$fEqPiece_$c==
                  ChessBoard.$fEqPiece_$c/= -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fEqPiece_$c/= ::
    ChessBoard.Piece -> ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Piece) (y :: ChessBoard.Piece) ->
                 case ChessBoard.$fEqPiece_$c== x2 y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fEqPiece_$c== ::
    ChessBoard.Piece -> ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Piece) (w1 :: ChessBoard.Piece) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Piece ww4 ww5 ->
                 ChessBoard.$w$c== ww1 ww2 ww4 ww5 } }) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fShowChessPiece :: GHC.Show.Show ChessBoard.ChessPiece
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.ChessPiece
                  ChessBoard.$fShowChessPiece_$cshowsPrec
                  ChessBoard.$fShowChessPiece_$cshow
                  ChessBoard.$fShowChessPiece_$cshowList -}
25775eee31cbf189b2548e0acf0539e2
  $fShowChessPiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece2) -}
ca26d966ac494f4f48eea368bbdda0f4
  $fShowChessPiece10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("B"#) -}
b2a801cd64ecec4ba7938382f39d7f80
  $fShowChessPiece11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece12) -}
84a876f167b63c95f11edef5b284bae1
  $fShowChessPiece12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("P"#) -}
0f0fc5b5e985338e6ce4254a2c105b57
  $fShowChessPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("K"#) -}
34d29b2ca1e694e818fb0ebaecce5738
  $fShowChessPiece3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece4) -}
c2ae05b02b435369b3e3b49884be3e1d
  $fShowChessPiece4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Q"#) -}
2f21ef97bfda4e3aea3641a8361cc574
  $fShowChessPiece5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece6) -}
8610584ca36bf44cfa09ddc14b33837a
  $fShowChessPiece6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("R"#) -}
b01a0db313f1e0f85ce61ebc38965dd9
  $fShowChessPiece7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece8) -}
dbe0392c77d072fb1674b8d722dd2884
  $fShowChessPiece8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("N"#) -}
9e9193ab9364ed59866a8c1ccfcad930
  $fShowChessPiece9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece10) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fShowChessPiece_$cshow :: ChessBoard.ChessPiece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.ChessPiece) ->
                 case ds of wild {
                   ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                   ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                   ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                   ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                   ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                   ChessBoard.King -> ChessBoard.$fShowChessPiece1 }) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fShowChessPiece_$cshowList ::
    [ChessBoard.ChessPiece] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.ChessPiece]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.ChessPiece
                   ChessBoard.$w$cshowsPrec
                   ls
                   s) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $fShowChessPiece_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.ChessPiece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.ChessPiece)
                   (w2 :: GHC.Base.String) ->
                 ChessBoard.$w$cshowsPrec w1 w2) -}
27801c70e04fd089bd52ac644edf6eba
  $fShowColor :: GHC.Show.Show ChessBoard.Color
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Color
                  ChessBoard.$fShowColor_$cshowsPrec
                  ChessBoard.$fShowColor_$cshow
                  ChessBoard.$fShowColor_$cshowList -}
27801c70e04fd089bd52ac644edf6eba
  $fShowColor1 :: ChessBoard.Color -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: ChessBoard.Color) (s :: GHC.Base.String) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n9 :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n9
                           ChessBoard.$fShowChessPiece9)
                        s
                   ChessBoard.White
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n9 :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n9 ChessBoard.$fShowColor2)
                        s }) -}
301c7f69f37a39fd99bfafca450f0230
  $fShowColor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowColor3) -}
f97401eb4a27b45ed9c67d6b048b26eb
  $fShowColor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("W"#) -}
27801c70e04fd089bd52ac644edf6eba
  $fShowColor_$cshow :: ChessBoard.Color -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Color) ->
                 case ds of wild {
                   ChessBoard.Black -> ChessBoard.$fShowChessPiece9
                   ChessBoard.White -> ChessBoard.$fShowColor2 }) -}
27801c70e04fd089bd52ac644edf6eba
  $fShowColor_$cshowList :: [ChessBoard.Color] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Color]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Color
                   ChessBoard.$fShowColor1
                   ls
                   s) -}
27801c70e04fd089bd52ac644edf6eba
  $fShowColor_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Color -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x2 :: ChessBoard.Color)
                   (s :: GHC.Base.String) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n9 :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n9
                           ChessBoard.$fShowChessPiece9)
                        s
                   ChessBoard.White
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n9 :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n9 ChessBoard.$fShowColor2)
                        s }) -}
84ebeb4fb08dba347017ed67982bc062
  $fShowGameOver :: GHC.Show.Show ChessBoard.GameOver
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.GameOver
                  ChessBoard.$fShowGameOver_$cshowsPrec
                  ChessBoard.$fShowGameOver_$cshow
                  ChessBoard.$fShowGameOver_$cshowList -}
4fd007f9dbb6a222b1a48713621846b8
  $fShowGameOver1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver2) -}
c010e5ed36ae8e1f8c58667f6c0115bf
  $fShowGameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Unfinished"#) -}
a4e692bd1cced4b7e22efb03494db34b
  $fShowGameOver3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver4) -}
25a01c9d6bb5c276f5df4cefdc7503c4
  $fShowGameOver4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StaleMate"#) -}
b6816a2cdc38cb195226a0e229c0fc0c
  $fShowGameOver5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver6) -}
ba85df85c53d3bc33f44b605fe093bbe
  $fShowGameOver6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CheckMate"#) -}
84ebeb4fb08dba347017ed67982bc062
  $fShowGameOver_$cshow :: ChessBoard.GameOver -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: ChessBoard.GameOver) ->
                 case x2 of wild {
                   ChessBoard.CheckMate -> ChessBoard.$fShowGameOver5
                   ChessBoard.StaleMate -> ChessBoard.$fShowGameOver3
                   ChessBoard.Unfinished -> ChessBoard.$fShowGameOver1 }) -}
84ebeb4fb08dba347017ed67982bc062
  $fShowGameOver_$cshowList ::
    [ChessBoard.GameOver] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.GameOver]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.GameOver
                   ChessBoard.$w$cshowsPrec1
                   ls
                   s) -}
84ebeb4fb08dba347017ed67982bc062
  $fShowGameOver_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.GameOver -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.GameOver)
                   (w2 :: GHC.Base.String) ->
                 ChessBoard.$w$cshowsPrec1 w1 w2) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation :: GHC.Show.Show ChessBoard.Location
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Location
                  ChessBoard.$fShowLocation_$cshowsPrec
                  ChessBoard.$fShowLocation_$cshow
                  ChessBoard.$fShowLocation_$cshowList -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation1 :: ChessBoard.Location -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U(U))><L,1*U>,
     Unfolding: (\ (w :: ChessBoard.Location) (w1 :: GHC.Base.String) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshowsPrec2 ww4 ww2 w1 } }) -}
a5f4a087ffe014a19991b83911e29fe8
  $fShowLocation10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation11) -}
e05337ad7fb843a0080cc9efe160a655
  $fShowLocation11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("D"#) -}
60b214e68244e6336d47689a99a04883
  $fShowLocation12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation13) -}
3ae6652c59a7d7f5ac97e12cedcd9700
  $fShowLocation13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("C"#) -}
37c51fcf6954abcf5660036a7abb8f99
  $fShowLocation14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation15) -}
bf1bee403446e6d736104ffac9686ed7
  $fShowLocation15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("A"#) -}
890f7f82e809ba9ff6b333ee11bd0bcc
  $fShowLocation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation17) -}
3821607b7609ee6621cb077cb538ecd5
  $fShowLocation17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Error"#) -}
fe1d2f2b173eb4c3166252eaf1f410ac
  $fShowLocation2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation3) -}
3718dd72a97cc974b195d31366fe643c
  $fShowLocation3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("H"#) -}
93bab02e4980e4f1f25313021fbde7c2
  $fShowLocation4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation5) -}
e43dd2f3232bc4ae097db783f752e30d
  $fShowLocation5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("G"#) -}
f41caea969b04014971bc066a64d4dd5
  $fShowLocation6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation7) -}
52394a462cbd20b22264f8197fdd3743
  $fShowLocation7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("F"#) -}
0f0f4c0bde349211d39a2079b0db613b
  $fShowLocation8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation9) -}
75876a2ac7ec0e9dcb403e8dd732f622
  $fShowLocation9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("E"#) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshow :: ChessBoard.Location -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshow ww4 ww2 } }) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshowList ::
    [ChessBoard.Location] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Location]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Location
                   ChessBoard.$fShowLocation1
                   ls
                   s) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Location -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,A><S(S(S)L),1*U(1*U(1*U),1*U(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.Location)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshowsPrec2 ww4 ww2 w2 } }) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fShowPiece :: GHC.Show.Show ChessBoard.Piece
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Piece
                  ChessBoard.$fShowPiece_$cshowsPrec
                  ChessBoard.$fShowPiece_$cshow
                  ChessBoard.$fShowPiece_$cshowList -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fShowPiece1 ::
    ChessBoard.Piece -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SL),1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: ChessBoard.Piece) (s :: GHC.Base.String)[OneShot] ->
                 case x2 of wild { ChessBoard.Piece c cp ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n9 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c1
                      n9
                      (ChessBoard.printPiece c cp))
                   s }) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fShowPiece_$cshow :: ChessBoard.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Piece) ->
                 case ds of wild { ChessBoard.Piece c cp ->
                 ChessBoard.printPiece c cp }) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fShowPiece_$cshowList :: [ChessBoard.Piece] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Piece]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Piece
                   ChessBoard.$fShowPiece1
                   ls
                   s) -}
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  $fShowPiece_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Piece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SL),1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x2 :: ChessBoard.Piece)
                   (s :: GHC.Base.String) ->
                 case x2 of wild { ChessBoard.Piece c cp ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n9 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c1
                      n9
                      (ChessBoard.printPiece c cp))
                   s }) -}
8e056af4d83966ffb6cca0fdd40d0ace
  $fShowPlayer :: GHC.Show.Show ChessBoard.Player
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Player
                  ChessBoard.$fShowPlayer_$cshowsPrec
                  ChessBoard.$fShowPlayer_$cshow
                  ChessBoard.$fShowPlayer_$cshowList -}
8e056af4d83966ffb6cca0fdd40d0ace
  $fShowPlayer1 :: ChessBoard.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U(U))><L,U>,
     Unfolding: (\ (w :: ChessBoard.Player) (w1 :: GHC.Base.String) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 ChessBoard.$w$cshowsPrec3 0# ww1 ww2 ww3 ww4 ww5 w1 }) -}
ebfc72f61778ace27caa99d0c2fa9c95
  $fShowPlayer2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
8e056af4d83966ffb6cca0fdd40d0ace
  $fShowPlayer_$cshow :: ChessBoard.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: ChessBoard.Player) ->
                 ChessBoard.$fShowPlayer_$cshowsPrec
                   ChessBoard.$fShowPlayer2
                   x2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8e056af4d83966ffb6cca0fdd40d0ace
  $fShowPlayer_$cshowList :: [ChessBoard.Player] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Player]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Player
                   ChessBoard.$fShowPlayer1
                   ls
                   s) -}
8e056af4d83966ffb6cca0fdd40d0ace
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Player -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.Player)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { ChessBoard.Player ww3 ww4 ww5 ww6 ww7 ->
                 ChessBoard.$w$cshowsPrec3 ww1 ww3 ww4 ww5 ww6 ww7 w2 } }) -}
6bbd0b1da256987b5c374ff1b28945be
  $tc'Backward :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3701717171427713210##
                   17837981855696506380##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Backward2
                   0#
                   ChessBoard.$tc'Backward1) -}
e98de1a6e1eeacd40a75f6d944575d95
  $tc'Backward1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
f1a5080ad09e1b546d09934d84896da4
  $tc'Backward2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Backward3) -}
0c603284576d27918016bc058b11e9c2
  $tc'Backward3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Backward"#) -}
f76ba18e19d0ea9d320ddf7137d61c3d
  $tc'Bishop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1859922600471315242##
                   9392862694933984042##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Bishop2
                   0#
                   ChessBoard.$tc'Bishop1) -}
8618b76cc4c5d06a52c67a374aba383c
  $tc'Bishop1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
b74d0a863ffb347c7c12e53881e029b0
  $tc'Bishop2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Bishop3) -}
f3f6bc3c781f667e98a2cfdb6fd73557
  $tc'Bishop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bishop"#) -}
00a647521c62022834ed1673528df508
  $tc'Black :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17360399565767765397##
                   10956204482306786931##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Black2
                   0#
                   ChessBoard.$tc'Black1) -}
02f82bda94a780954775af5aa83f96f9
  $tc'Black1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
effc5bca8673faf71501b9db6375ecbf
  $tc'Black2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Black3) -}
44348573747af1a772959c5c880a9aad
  $tc'Black3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Black"#) -}
f72dcde621eecbfff900986c11643939
  $tc'CheckMate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   244229523097746280##
                   6713682609734780876##
                   ChessBoard.$trModule
                   ChessBoard.$tc'CheckMate2
                   0#
                   ChessBoard.$tc'CheckMate1) -}
9bd4a178aa80c2744e1c58bdd00584ec
  $tc'CheckMate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
b706b236ccb5f72e9ef8831df20d0530
  $tc'CheckMate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'CheckMate3) -}
16ab9fc0ba091fadb60f11e67ec7d5bf
  $tc'CheckMate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CheckMate"#) -}
d26f7a8337a0cf375f6f837a3c666923
  $tc'DiagBL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6376024874887997916##
                   6618291504245642917##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagBL1
                   0#
                   ChessBoard.$tc'Backward1) -}
626e394a07db5c34da0ba2216e8ecef8
  $tc'DiagBL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagBL2) -}
b490bf3e12a305605d3e24c323e2a12c
  $tc'DiagBL2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagBL"#) -}
4319638970d2bce6a52c001c49e1e4c9
  $tc'DiagBR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10314828229921814719##
                   8189800409704871031##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagBR1
                   0#
                   ChessBoard.$tc'Backward1) -}
e26f6bff9fae7f79146ae08a9933ebed
  $tc'DiagBR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagBR2) -}
62633b0da65acd0f23b5aec3621c55e3
  $tc'DiagBR2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagBR"#) -}
3b394f101e9952ed2512ef1957ac4359
  $tc'DiagFL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14156882257518125914##
                   5128305356499999878##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagFL1
                   0#
                   ChessBoard.$tc'Backward1) -}
d5c9c08be0cb9544ad6c2d0c7fdf931f
  $tc'DiagFL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagFL2) -}
33ed516122811b7a8298773d38e0c6c5
  $tc'DiagFL2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagFL"#) -}
03b69a2c1f8a83fadb2dbd5aaefc2e2a
  $tc'DiagFR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18363776098993942452##
                   5773539533621295392##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagFR1
                   0#
                   ChessBoard.$tc'Backward1) -}
f2326ac2016f8dd92f15bf204092ec66
  $tc'DiagFR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagFR2) -}
541b9dd7979b806d98e473c85d151e07
  $tc'DiagFR2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagFR"#) -}
2762b5fc69b5a946aa3edcc8039d2288
  $tc'Forward :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14249913380963119407##
                   11123840718080238294##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Forward1
                   0#
                   ChessBoard.$tc'Backward1) -}
4cfdeb00508ad1390cd2161b036cf483
  $tc'Forward1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Forward2) -}
03a7674c798c5ccdf08f1c4078072729
  $tc'Forward2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Forward"#) -}
d61287b576e030d21f03088394eb13b3
  $tc'Game :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17864205669972082914##
                   16982876703268251754##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Game2
                   0#
                   ChessBoard.$tc'Game1) -}
e73763d724abae745e8125dc7ddd75a4
  $tc'Game1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
deec658d22298d1031af4fe23f7a7ec3
  $tc'Game2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Game3) -}
9e6d8b21fbb11fe9341e8880554510bb
  $tc'Game3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Game"#) -}
3e4f3a705d2092217fcf6a13fad1cf2d
  $tc'King :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14212754542616103717##
                   7554362502951841670##
                   ChessBoard.$trModule
                   ChessBoard.$tc'King1
                   0#
                   ChessBoard.$tc'Bishop1) -}
90785b9edd6fb11875c5c69a9cc5ee6c
  $tc'King1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'King2) -}
46b1065b1f802e8a9e0eb4aa3cdf94ef
  $tc'King2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'King"#) -}
4aa219b688665a4bb3a8f1004a229d00
  $tc'Knight :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15217035523706160804##
                   3502406585153355550##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Knight1
                   0#
                   ChessBoard.$tc'Bishop1) -}
5caf2180c99ec4e23ed08d6e4232d230
  $tc'Knight1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Knight2) -}
ea20503bb07c289ca0b113915acca7d4
  $tc'Knight2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Knight"#) -}
5387b89f7b07e94614d721735d5a4741
  $tc'Leftt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7493666668227912972##
                   12540698331853241459##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Leftt1
                   0#
                   ChessBoard.$tc'Backward1) -}
9922ed2e830fd5aa303fc8f516410a47
  $tc'Leftt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Leftt2) -}
f07425f940265e19df12f9b01220abef
  $tc'Leftt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leftt"#) -}
40aa7374febe7013549054d073408a1e
  $tc'Location :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9062991653214768393##
                   7337080452892193561##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Location2
                   0#
                   ChessBoard.$tc'Location1) -}
6329b51a8c686d372b474dcebc1c88b5
  $tc'Location1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
31c519aef26b44200a8d029960821d58
  $tc'Location2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Location3) -}
2f04a37a7fe3212a56203e71a1733c4d
  $tc'Location3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Location"#) -}
585374a118b23666494f910a3ee79e98
  $tc'Pawn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6334934572900286720##
                   10133371348699454777##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Pawn1
                   0#
                   ChessBoard.$tc'Bishop1) -}
b3f856d45e9b4f6d13d8586b2225bff5
  $tc'Pawn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Pawn2) -}
82c67bc720d79e2d06db73fd11b45a6c
  $tc'Pawn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pawn"#) -}
0c6f7b08897956a4e46df42a97113d6f
  $tc'Piece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7755712274710907797##
                   14249138036874745735##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Piece2
                   0#
                   ChessBoard.$tc'Piece1) -}
14c3c7d38c2b97aff6e7e434fc037dad
  $tc'Piece1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4f6df4c0e1de5cf2c9f4a9b437350f6e
  $tc'Piece2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Piece3) -}
0c6ca6eaba050c452fa1c89c593b7b89
  $tc'Piece3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Piece"#) -}
b2fe241d1e0f097c2eb7a04306320bc6
  $tc'Player :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5983525802846579206##
                   18334041469456993763##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Player2
                   0#
                   ChessBoard.$tc'Player1) -}
c0a45672a95ecd2b7cf774056e0d52ab
  $tc'Player1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9cb816f527ad254495ad3a889df74b4d
  $tc'Player2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Player3) -}
37723fc3291647f711fe5af93bd70e29
  $tc'Player3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Player"#) -}
702b5ba2b18593cdeae0bc14ff724bde
  $tc'Queen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10427081638620225486##
                   11982980599722597220##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Queen1
                   0#
                   ChessBoard.$tc'Bishop1) -}
022d504e72858eb1dc6bc33d8d5f74e5
  $tc'Queen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Queen2) -}
00d3073bf1b18df5aa5bc8145eac59b0
  $tc'Queen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Queen"#) -}
db1343954e4fb141be0120adc34c840d
  $tc'Rightt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17726700910068818784##
                   7541693408495280534##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Rightt1
                   0#
                   ChessBoard.$tc'Backward1) -}
e4db1d766aca27dc32c9e6d9201d2e00
  $tc'Rightt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Rightt2) -}
2601912ec1bcbb6ea7f4da515e5c3b39
  $tc'Rightt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rightt"#) -}
4361cd45d19efcf5b8cf269d410e395b
  $tc'Rook :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2765951124866374374##
                   429280785758157496##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Rook1
                   0#
                   ChessBoard.$tc'Bishop1) -}
8ede3ffae7d71738e4a7d4572c7b561f
  $tc'Rook1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Rook2) -}
1c4dcd3bedcbabcb9e1b7b8082117ffe
  $tc'Rook2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rook"#) -}
2ad4d1223b2d1c2d315eb15f4d11ea39
  $tc'StaleMate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4918757790118876704##
                   481521187216262725##
                   ChessBoard.$trModule
                   ChessBoard.$tc'StaleMate1
                   0#
                   ChessBoard.$tc'CheckMate1) -}
2f0b56e27cf527f2dc28fc24a4c4175e
  $tc'StaleMate1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'StaleMate2) -}
9886a647b903cc8e65420006b7db52a3
  $tc'StaleMate2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StaleMate"#) -}
6a5a83bbe06e20ef1544b796c9f02e6f
  $tc'Unfinished :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9828605474628407994##
                   292116914215697706##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Unfinished1
                   0#
                   ChessBoard.$tc'CheckMate1) -}
bdb2db90bcf600f2dd80ea58464f94a8
  $tc'Unfinished1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Unfinished2) -}
36fcbaefd95974ba1fc4eb4a6081559a
  $tc'Unfinished2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unfinished"#) -}
a9a85a4f5e8722e2e7a032a8c4dac513
  $tc'White :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7473999497024262200##
                   10331176697546301907##
                   ChessBoard.$trModule
                   ChessBoard.$tc'White1
                   0#
                   ChessBoard.$tc'Black1) -}
9caba357de3e681c8cc46b7a073f1cad
  $tc'White1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'White2) -}
8fa322a5cac174e1c44d3b48930e8581
  $tc'White2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'White"#) -}
e8952c1929180d36bcab8b320e098e7d
  $tcChessPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7777171357180282469##
                   13597314580726789729##
                   ChessBoard.$trModule
                   ChessBoard.$tcChessPiece1
                   0#
                   GHC.Types.krep$*) -}
c46fb4c8bc6f3ec9cd5638495a42e9ff
  $tcChessPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcChessPiece2) -}
ba5b03863baa28d758afe2a3f888e54e
  $tcChessPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChessPiece"#) -}
e5f766bb5ceb8214299e4e4c782fa684
  $tcColor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2967709801297043498##
                   16171954743078143482##
                   ChessBoard.$trModule
                   ChessBoard.$tcColor1
                   0#
                   GHC.Types.krep$*) -}
9e7443ac618592cf54b1d015ddf2a7aa
  $tcColor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcColor2) -}
da125fe09bac6416b592e2e856f6e3e8
  $tcColor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Color"#) -}
018a6f5394a5653a7a644b36dd94c425
  $tcDirection :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15838310744117077221##
                   8057800576995639210##
                   ChessBoard.$trModule
                   ChessBoard.$tcDirection1
                   0#
                   GHC.Types.krep$*) -}
76a1301a562d8a79a9574ce166075aeb
  $tcDirection1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcDirection2) -}
31f6022eb4d13f3b68548b3d39d728eb
  $tcDirection2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Direction"#) -}
428a8a7716fa3a9b118f51a241efb43e
  $tcGame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3132135774796161636##
                   9322976130798821795##
                   ChessBoard.$trModule
                   ChessBoard.$tcGame1
                   0#
                   GHC.Types.krep$*) -}
a882cf40a198865bc49b3ddec238ed30
  $tcGame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcGame2) -}
2c5debd32faa97b7c0659df75d3808ad
  $tcGame2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Game"#) -}
d5e56e84d9101b03ebc5ab5f1eb24c12
  $tcGameOver :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18176669151516859591##
                   1818438445336014487##
                   ChessBoard.$trModule
                   ChessBoard.$tcGameOver1
                   0#
                   GHC.Types.krep$*) -}
9beeabf524386bd003c28e3852351978
  $tcGameOver1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcGameOver2) -}
0e4286ddd800378edf825171398aa802
  $tcGameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GameOver"#) -}
45d2282971ceff46e258d067eb3c9786
  $tcLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9003094257349354805##
                   7506062213225909215##
                   ChessBoard.$trModule
                   ChessBoard.$tcLocation1
                   0#
                   GHC.Types.krep$*) -}
08cf8521325c1efbac3ce2850c164de4
  $tcLocation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcLocation2) -}
7b6655aa7ad77b01b08d2c7c59d4af30
  $tcLocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Location"#) -}
726abc874b58293b5cefbec328ce829b
  $tcPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   148386750547179083##
                   17058407329145243634##
                   ChessBoard.$trModule
                   ChessBoard.$tcPiece1
                   0#
                   GHC.Types.krep$*) -}
a5bdbba1d08819b7d46651b3b8255b91
  $tcPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcPiece2) -}
a8a8ce4c1632f694e29628d01d153b55
  $tcPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Piece"#) -}
c65346cb0c9746f03c4e93cb2358fd93
  $tcPlayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9042444837851077251##
                   17916954981088333718##
                   ChessBoard.$trModule
                   ChessBoard.$tcPlayer1
                   0#
                   GHC.Types.krep$*) -}
b01f40850e958242ef99c9bc2ac78c09
  $tcPlayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcPlayer2) -}
1f9eee05ec4b0401a8858d1402a6f331
  $tcPlayer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player"#) -}
3610b7d4d46a9056b8cfd1e9684cf721
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ChessBoard.$trModule3
                   ChessBoard.$trModule1) -}
a3f731f006517cefce0b05ecbb7a6084
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$trModule2) -}
5a879a63aef343911723d9e2921ada42
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChessBoard"#) -}
c9293ec950687ba9eab5a696cf3a7007
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$trModule4) -}
bf40c7b384d489d57ba48e7662a754a2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
715d2895152f8be347c87ff00d700b03
  $w$c== ::
    ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Color)
                   (ww1 :: ChessBoard.ChessPiece)
                   (ww2 :: ChessBoard.Color)
                   (ww3 :: ChessBoard.ChessPiece) ->
                 case ww of wild {
                   ChessBoard.Black
                   -> case ww2 of wild1 {
                        ChessBoard.Black -> ChessBoard.$fEqChessPiece_$c== ww1 ww3
                        ChessBoard.White -> GHC.Types.False }
                   ChessBoard.White
                   -> case ww2 of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> ChessBoard.$fEqChessPiece_$c== ww1 ww3 } }) -}
5205fb34987bffa3a09968daac1282e8
  $w$cshow :: GHC.Prim.Int# -> ChessBoard.RowLoc -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: ChessBoard.RowLoc) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintCol ww)
                   (case ww1 of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
a9339aa10bc82e16fb147d7654bbb4ff
  $w$cshowsPrec ::
    ChessBoard.ChessPiece -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.ChessPiece)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   ChessBoard.Pawn
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece11 w1
                   ChessBoard.Bishop
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece9 w1
                   ChessBoard.Knight
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece7 w1
                   ChessBoard.Rook
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece5 w1
                   ChessBoard.Queen
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece3 w1
                   ChessBoard.King
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowChessPiece1
                        w1 }) -}
84ebeb4fb08dba347017ed67982bc062
  $w$cshowsPrec1 ::
    ChessBoard.GameOver -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.GameOver) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   ChessBoard.CheckMate
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver5 w1
                   ChessBoard.StaleMate
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver3 w1
                   ChessBoard.Unfinished
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver1 w1 }) -}
e5987e4d79a55bc89f789668aac5378c
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> ChessBoard.RowLoc -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,1*U(U)><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (w :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintCol ww)
                   (case ww1 of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++_$s++ @ GHC.Types.Char w ww5 ww6 } })) -}
8df659431a2d2f666d3b2611118c9933
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> ChessBoard.Color
    -> ChessBoard.Pieces
    -> ChessBoard.Pieces
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [2] -}
086daf9d97edf53b18a16e0c618b5b91
  $wchangeBoard ::
    ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> [[GHC.Maybe.Maybe ChessBoard.Piece]]
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(U)><S,U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (w1 :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w2 :: ChessBoard.ColLoc)
                   (ww :: GHC.Prim.Int#) ->
                 let {
                   $j :: [ChessBoard.Row]
                         -> [ChessBoard.Row] -> [[GHC.Maybe.Maybe ChessBoard.Piece]]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (x2 :: [ChessBoard.Row])[OneShot]
                       (ds1 :: [ChessBoard.Row])[OneShot] ->
                     GHC.Base.++
                       @ [GHC.Maybe.Maybe ChessBoard.Piece]
                       x2
                       (GHC.Types.:
                          @ [GHC.Maybe.Maybe ChessBoard.Piece]
                          (case w2 of wild { GHC.Types.I# x3 ->
                           case GHC.Prim.<=# x3 0# of lwild {
                             DEFAULT
                             -> case ds1 of wild1 {
                                  []
                                  -> case GHC.List.badHead
                                     ret_ty [GHC.Maybe.Maybe ChessBoard.Piece]
                                     of {}
                                  : x4 ds2
                                  -> case x4 of wild2 {
                                       []
                                       -> GHC.Base.++
                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                            (GHC.Types.[] @ (GHC.Maybe.Maybe ChessBoard.Piece))
                                            (GHC.Types.:
                                               @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                               w1
                                               (GHC.List.scanl2
                                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)))
                                       : ipv ipv1
                                       -> case x3 of ds3 {
                                            DEFAULT
                                            -> let {
                                                 ds4 :: ([GHC.Maybe.Maybe ChessBoard.Piece],
                                                         [GHC.Maybe.Maybe ChessBoard.Piece])
                                                 = case GHC.List.splitAt_$s$wsplitAt'
                                                          @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                          ipv1
                                                          (GHC.Prim.-#
                                                             ds3
                                                             1#) of ww1 { (#,#) ww2 ww3 ->
                                                   (ww2, ww3) }
                                               } in
                                               GHC.Base.++_$s++
                                                 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                 (GHC.Types.:
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                    w1
                                                    (case ds4 of wild3 { (,) xs' xs'' ->
                                                     case xs'' of wild4 {
                                                       []
                                                       -> GHC.List.scanl2
                                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                       : ds5 xs -> xs } }))
                                                 ipv
                                                 (case ds4 of wild3 { (,) xs' xs'' -> xs' })
                                            1#
                                            -> GHC.Base.++_$s++
                                                 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                 (GHC.Types.:
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                    w1
                                                    (case ipv1 of wild3 {
                                                       []
                                                       -> GHC.List.scanl2
                                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                       : ds4 xs -> xs }))
                                                 ipv
                                                 (GHC.Types.[]
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)) } } }
                             1#
                             -> GHC.Base.++
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.Types.[] @ (GHC.Maybe.Maybe ChessBoard.Piece))
                                  (GHC.Types.:
                                     @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                     w1
                                     (case ds1 of wild1 {
                                        []
                                        -> case GHC.List.badHead
                                           ret_ty [GHC.Maybe.Maybe ChessBoard.Piece]
                                           of {}
                                        : x4 ds2
                                        -> case x4 of wild2 {
                                             []
                                             -> GHC.List.scanl2 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                             : ds3 xs -> xs } })) } })
                          (case ds1 of wild {
                             [] -> GHC.List.scanl2 @ ChessBoard.Row : ds2 xs -> xs }))
                 } in
                 case GHC.Prim.<=# ww 0# of lwild {
                   DEFAULT
                   -> case w of wild {
                        []
                        -> $j
                             (GHC.Types.[] @ ChessBoard.Row)
                             (GHC.Types.[] @ ChessBoard.Row)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([ChessBoard.Row], [ChessBoard.Row])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ ChessBoard.Row
                                           ipv1
                                           (GHC.Prim.-# ds1 1#) of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                $j
                                  (GHC.Types.:
                                     @ ChessBoard.Row
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (case ds2 of wild2 { (,) xs' xs'' -> xs'' })
                             1#
                             -> $j
                                  (GHC.Types.: @ ChessBoard.Row ipv (GHC.Types.[] @ ChessBoard.Row))
                                  ipv1 } }
                   1# -> $j (GHC.Types.[] @ ChessBoard.Row) w }) -}
a6fcdc056b1cdeb6c8dcacb8b45b785e
  $wcheckPawnPromotion ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U><S,U><S,U><L,1*U(1*U)>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: ChessBoard.RowLoc) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row ww ww2)
                        ww1 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1
                   -> case a1 of wild1 { ChessBoard.Piece ds cp ->
                      case cp of wild2 {
                        ChessBoard.Pawn
                        -> case ww3 of wild3 { GHC.Types.I# x2 ->
                           case x2 of wild4 {
                             DEFAULT -> GHC.Types.False
                             0# -> GHC.Types.True
                             7# -> GHC.Types.True } }
                        ChessBoard.Bishop -> GHC.Types.False
                        ChessBoard.Knight -> GHC.Types.False
                        ChessBoard.Rook -> GHC.Types.False
                        ChessBoard.Queen -> GHC.Types.False
                        ChessBoard.King -> GHC.Types.False } } }) -}
d3cd3337d4f5f7d4fa2f0013a4e22b3c
  $wcheckPiece ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 3, Strictness: <L,1*U><S,U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: ChessBoard.RowLoc) ->
                 case GHC.Prim.># ww 7# of lwild {
                   DEFAULT
                   -> case GHC.Prim.<# ww 0# of lwild1 {
                        DEFAULT
                        -> case w1 of wild { GHC.Types.I# x2 ->
                           case GHC.Prim.># x2 7# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.<# x2 0# of lwild3 {
                                  DEFAULT
                                  -> GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w x2)
                                       ww
                                  1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }
                             1# -> GHC.Maybe.Nothing @ ChessBoard.Piece } }
                        1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }
                   1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }) -}
18958cfe00cab08202bd736d6db7a04e
  $wcycleBoardCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U,A,A)><L,U><S,U><S,U>,
     Inline: [2] -}
60d0584fe3e9afd432bedb5893657517
  $wcycleMoveCheck ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,U><L,U><S,U><S,U>, Inline: [2] -}
ecd1acda97dc24efa04311059873ddd0
  $wfirstPiece ::
    ChessBoard.Direction
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 4, Strictness: <L,U><S,U><L,1*U(U)><L,U>, Inline: [2] -}
d3e3318effe9324496b7a12c521732ac
  $wgetKingInBoard ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 4, Strictness: <S,U><L,U><S,1*U><S,U>, Inline: [2] -}
bd4dfaa584b1b6cbc7be5503ff7274fe
  $wisAnyBishopMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 let {
                   col :: ChessBoard.ColLoc = GHC.Types.I# ww
                 } in
                 case ChessBoard.$wisAnyMoveRecurse
                        w
                        w1
                        col
                        w2
                        (GHC.Prim.+# ww 1#)
                        (case w2 of wild { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.+# x2 1#) })
                        ChessBoard.DiagFR of wild {
                   GHC.Types.False
                   -> case ChessBoard.$wisAnyMoveRecurse
                             w
                             w1
                             col
                             w2
                             (GHC.Prim.-# ww 1#)
                             (case w2 of wild1 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.+# x2 1#) })
                             ChessBoard.DiagFL of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.+# ww 1#)
                                  (case w2 of wild2 { GHC.Types.I# x2 ->
                                   GHC.Types.I# (GHC.Prim.-# x2 1#) })
                                  ChessBoard.DiagBR of wild2 {
                             GHC.Types.False
                             -> ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.-# ww 1#)
                                  (case w2 of wild3 { GHC.Types.I# x2 ->
                                   GHC.Types.I# (GHC.Prim.-# x2 1#) })
                                  ChessBoard.DiagBL
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
41ce079dc4753f39d00a773cce8a4bce
  $wisAnyKingMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
e5518e35dbfad9693dd250e6ba63f178
  $wisAnyKnightMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
1d27536b7d7b8d14a13fb8649031bb4d
  $wisAnyMoveRecurse ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Direction
    -> GHC.Types.Bool
  {- Arity: 7,
     Strictness: <L,1*U(U,A,A)><L,U><L,1*U(U)><L,U(U)><S,U><L,1*U(U)><L,U>,
     Inline: [2] -}
2970e88b3c82eb233a5bf56dfa9c63cd
  $wisAnyPawnMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
ee0b2e5420cc211462c6dd96fbae64ff
  $wisAnyQueenMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 case ChessBoard.$wisAnyBishopMove w w1 ww w2 of wild {
                   GHC.Types.False -> ChessBoard.$wisAnyRookMove w w1 ww w2
                   GHC.Types.True -> GHC.Types.True }) -}
4096873429dbeda41f427d945de7599c
  $wisAnyRookMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 let {
                   col :: ChessBoard.ColLoc = GHC.Types.I# ww
                 } in
                 case ChessBoard.$wisAnyMoveRecurse
                        w
                        w1
                        col
                        w2
                        ww
                        (case w2 of wild { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.+# x2 1#) })
                        ChessBoard.Forward of wild {
                   GHC.Types.False
                   -> case ChessBoard.$wisAnyMoveRecurse
                             w
                             w1
                             col
                             w2
                             ww
                             (case w2 of wild1 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.-# x2 1#) })
                             ChessBoard.Backward of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.-# ww 1#)
                                  w2
                                  ChessBoard.Leftt of wild2 {
                             GHC.Types.False
                             -> ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.+# ww 1#)
                                  w2
                                  ChessBoard.Rightt
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
ec223651cf9ed3775f3df41f34e647cb
  $wisClearPath ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><L,U>, Inline: [2] -}
463b5e8f0ed142f2ff246fcedab238f9
  $wisGameOver ::
    ChessBoard.Board -> ChessBoard.Color -> ChessBoard.GameOver
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board) (w :: ChessBoard.Color) ->
                 let {
                   wild :: ChessBoard.Game
                   = ChessBoard.Game ww ChessBoard.isGameOver1 ChessBoard.isGameOver1
                 } in
                 let {
                   $j :: ChessBoard.GameOver <join 0>
                   = case ChessBoard.$wcycleBoardCheck wild w 0# 0# of wild1 {
                       GHC.Types.False -> ChessBoard.StaleMate
                       GHC.Types.True -> ChessBoard.Unfinished }
                 } in
                 case ChessBoard.isKingInCheck ww w of wild1 {
                   GHC.Types.False -> $j
                   GHC.Types.True
                   -> case ChessBoard.$wcycleBoardCheck wild w 0# 0# of wild2 {
                        GHC.Types.False -> ChessBoard.CheckMate
                        GHC.Types.True -> $j } }) -}
cf58d13dfd6651e7743db6b1c32f7b7a
  $wisOpen ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,U><S,U><S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w :: ChessBoard.Board) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row w ww1)
                        ww of wild {
                   GHC.Maybe.Nothing -> GHC.Types.True
                   GHC.Maybe.Just a1 -> GHC.Types.False }) -}
407d2e5c6c17a8d9902997091f12d25e
  $wisValidBishopMovement ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww
                     } in
                     let {
                       x3 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT
                       -> case GHC.Prim.>=# x3 0# of lwild1 {
                            DEFAULT
                            -> case GHC.Prim./=#
                                      (GHC.Prim.negateInt# x2)
                                      (GHC.Prim.negateInt# x3) of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                            1#
                            -> case GHC.Prim./=# (GHC.Prim.negateInt# x2) x3 of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                       1#
                       -> case GHC.Prim.>=# x3 0# of lwild1 {
                            DEFAULT
                            -> case GHC.Prim./=# x2 (GHC.Prim.negateInt# x3) of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                            1#
                            -> case GHC.Prim./=# x2 x3 of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
aef732ff49b7b1820fe3932b0a956791
  $wisValidKingMovement ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww
                     } in
                     let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           x3 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                         } in
                         case GHC.Prim.>=# x3 0# of lwild {
                           DEFAULT
                           -> case GHC.Prim.># (GHC.Prim.negateInt# x3) 1# of lwild1 {
                                DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                           1#
                           -> case GHC.Prim.># x3 1# of lwild1 {
                                DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT
                       -> case GHC.Prim.># (GHC.Prim.negateInt# x2) 1# of lwild1 {
                            DEFAULT -> $j1 1# -> GHC.Types.False }
                       1#
                       -> case GHC.Prim.># x2 1# of lwild1 {
                            DEFAULT -> $j1 1# -> GHC.Types.False } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
7fb60cbbb95cb9693176181a0efaca31
  $wisValidKnightMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U(U)><S,U><L,U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                     } in
                     let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           $j2 :: GHC.Types.Bool <join 0>
                           = case ww2 of wild { GHC.Types.I# x3 ->
                             case ww of wild1 { GHC.Types.I# y ->
                             let {
                               x4 :: GHC.Prim.Int# = GHC.Prim.-# x3 y
                             } in
                             case GHC.Prim.>=# x4 0# of lwild {
                               DEFAULT
                               -> case x4 of lwild1 {
                                    DEFAULT -> GHC.Types.False -1# -> GHC.Types.True }
                               1#
                               -> case x4 of wild2 {
                                    DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } } }
                         } in
                         case GHC.Prim.>=# x2 0# of lwild {
                           DEFAULT
                           -> case x2 of lwild1 { DEFAULT -> GHC.Types.True -2# -> $j2 }
                           1# -> case x2 of wild { DEFAULT -> GHC.Types.True 2# -> $j2 } }
                     } in
                     let {
                       $j2 :: GHC.Types.Bool <join 0>
                       = case ww2 of wild { GHC.Types.I# x3 ->
                         case ww of wild1 { GHC.Types.I# y ->
                         let {
                           x4 :: GHC.Prim.Int# = GHC.Prim.-# x3 y
                         } in
                         case GHC.Prim.>=# x4 0# of lwild {
                           DEFAULT
                           -> case x4 of lwild1 { DEFAULT -> GHC.Types.False -2# -> $j1 }
                           1#
                           -> case x4 of wild2 { DEFAULT -> GHC.Types.False 2# -> $j1 } } } }
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT -> case x2 of lwild1 { DEFAULT -> $j1 -1# -> $j2 }
                       1# -> case x2 of wild { DEFAULT -> $j1 1# -> $j2 } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
56ad51e6b198cc8831f10bd2cc60d369
  $wisValidMove ::
    GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (# GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String #)
  {- Arity: 4,
     Strictness: <S,1*U><L,1*U(U(U),U(U))><L,1*U(U(U),U(U))><L,U>,
     Inline: [2] -}
7010fb4cf8c2ca7dd73e5602d8674c06
  $wisValidMovement ::
    ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><S,1*U><L,U(U)><S,U><L,U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Color)
                   (ww1 :: ChessBoard.ChessPiece)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: ChessBoard.ColLoc)
                   (ww5 :: GHC.Prim.Int#) ->
                 case ww1 of wild {
                   ChessBoard.Pawn
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidPawnMovement ww ww7 ww3 ww9 ww5 } }
                   ChessBoard.Bishop
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidBishopMovement ww7 ww3 ww9 ww5 } }
                   ChessBoard.Knight
                   -> ChessBoard.$wisValidKnightMovement ww2 ww3 ww4 ww5
                   ChessBoard.Rook -> ChessBoard.$wisValidRookMovement ww2 ww3 ww4 ww5
                   ChessBoard.Queen
                   -> ChessBoard.$wisValidQueenMovement ww2 ww3 ww4 ww5
                   ChessBoard.King
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidKingMovement ww7 ww3 ww9 ww5 } } }) -}
44f5c511f3a43ecbe663bfd87195e7c1
  $wisValidMovementPiece ::
    ChessBoard.Piece
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(U,1*U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Piece)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: ChessBoard.RowLoc) ->
                 case GHC.Prim.<# ww 0# of lwild {
                   DEFAULT
                   -> case ww1 of wild { GHC.Types.I# x2 ->
                      case GHC.Prim.<# x2 0# of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.># ww 7# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.># x2 7# of lwild3 {
                                  DEFAULT
                                  -> case ww2 of wild1 { GHC.Types.I# x3 ->
                                     case GHC.Prim.<# x3 0# of lwild4 {
                                       DEFAULT
                                       -> case ww3 of wild2 { GHC.Types.I# x4 ->
                                          case GHC.Prim.<# x4 0# of lwild5 {
                                            DEFAULT
                                            -> case GHC.Prim.># x3 7# of lwild6 {
                                                 DEFAULT
                                                 -> case GHC.Prim.># x4 7# of lwild7 {
                                                      DEFAULT
                                                      -> case w of ww4 { ChessBoard.Piece ww5 ww6 ->
                                                         ChessBoard.$wisValidMovement
                                                           ww5
                                                           ww6
                                                           (GHC.Types.I# ww)
                                                           x2
                                                           wild1
                                                           x4 }
                                                      1# -> GHC.Types.False }
                                                 1# -> GHC.Types.False }
                                            1# -> GHC.Types.False } }
                                       1# -> GHC.Types.False } }
                                  1# -> GHC.Types.False }
                             1# -> GHC.Types.False }
                        1# -> GHC.Types.False } }
                   1# -> GHC.Types.False }) -}
d6338b5034f233b1ace2592a23b6dc34
  $wisValidPawnAttack ::
    ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 6, Strictness: <L,U><S,U><L,U(U)><S,U><L,U(U)><L,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: ChessBoard.RowLoc)
                   (w1 :: ChessBoard.Board) ->
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww ww2
                 } in
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           $j2 :: GHC.Types.Bool <join 0>
                           = case ww3 of ww4 { GHC.Types.I# ww5 ->
                             case GHC.List.$w!!
                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                    (GHC.List.$w!! @ ChessBoard.Row w1 ww5)
                                    ww2 of wild {
                               GHC.Maybe.Nothing -> GHC.Types.False
                               GHC.Maybe.Just a1
                               -> case a1 of wild1 { ChessBoard.Piece enemyColor ds ->
                                  ChessBoard.$fEqColor_$c/= w enemyColor } } }
                         } in
                         case w of wild {
                           ChessBoard.Black -> $j2
                           ChessBoard.White
                           -> case ww3 of wild1 { GHC.Types.I# x3 ->
                              case ww1 of wild2 { GHC.Types.I# y ->
                              case GHC.Prim.-# x3 y of wild3 {
                                DEFAULT -> GHC.Types.False 1# -> $j2 } } } }
                     } in
                     case w of wild {
                       ChessBoard.Black
                       -> case ww1 of wild1 { GHC.Types.I# x3 ->
                          case ww3 of wild2 { GHC.Types.I# y ->
                          case GHC.Prim.-# x3 y of wild3 {
                            DEFAULT -> GHC.Types.False 1# -> $j1 } } }
                       ChessBoard.White -> $j1 }
                 } in
                 case GHC.Prim.>=# x2 0# of lwild {
                   DEFAULT
                   -> case x2 of lwild1 { DEFAULT -> GHC.Types.False -1# -> $j }
                   1# -> case x2 of wild { DEFAULT -> GHC.Types.False 1# -> $j } }) -}
3b50d48ca47ec3659ccf83c84920dc36
  $wisValidPawnMovement ::
    ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case GHC.Prim./=# ww ww2 of lwild {
                       DEFAULT
                       -> let {
                            $j1 :: GHC.Types.Bool <join 0>
                            = case w of wild {
                                ChessBoard.Black
                                -> GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# (GHC.Prim.+# ww3 1#) ww1)
                                ChessBoard.White
                                -> case ww1 of wild1 {
                                     DEFAULT
                                     -> GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.==# (GHC.Prim.-# ww3 1#) wild1)
                                     1#
                                     -> case ww3 of wild2 {
                                          DEFAULT -> GHC.Types.False
                                          2# -> GHC.Types.True
                                          3# -> GHC.Types.True } } }
                          } in
                          case w of wild {
                            ChessBoard.Black
                            -> case ww1 of wild1 {
                                 DEFAULT -> $j1
                                 6# -> case ww3 of wild2 { DEFAULT -> $j1 4# -> GHC.Types.True } }
                            ChessBoard.White -> $j1 }
                       1# -> GHC.Types.False }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
c0fe0025d0af3915167da3052971a5fb
  $wisValidPlayerMove ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Color
    -> (# GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String #)
  {- Arity: 6,
     Strictness: <L,U><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.RowLoc)
                   (ww3 :: ChessBoard.ColLoc)
                   (ww4 :: ChessBoard.RowLoc)
                   (w :: ChessBoard.Color) ->
                 case GHC.Prim.># ww1 7# of lwild {
                   DEFAULT
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case GHC.Prim.># x2 7# of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.<# ww1 0# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.<# x2 0# of lwild3 {
                                  DEFAULT
                                  -> case ww3 of wild1 { GHC.Types.I# x3 ->
                                     case GHC.Prim.># x3 7# of lwild4 {
                                       DEFAULT
                                       -> case ww4 of wild2 { GHC.Types.I# x4 ->
                                          case GHC.Prim.># x4 7# of lwild5 {
                                            DEFAULT
                                            -> case GHC.Prim.<# x3 0# of lwild6 {
                                                 DEFAULT
                                                 -> case GHC.Prim.<# x4 0# of lwild7 {
                                                      DEFAULT
                                                      -> case GHC.List.$w!!
                                                                @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                                (GHC.List.$w!!
                                                                   @ ChessBoard.Row
                                                                   ww
                                                                   x2)
                                                                ww1 of wild3 {
                                                           GHC.Maybe.Nothing
                                                           -> (# GHC.Types.False,
                                                                 ChessBoard.isValidPlayerMove10 #)
                                                           GHC.Maybe.Just ipv
                                                           -> let {
                                                                $j :: (# GHC.Types.Bool,
                                                                         GHC.Maybe.Maybe
                                                                           GHC.Base.String #)
                                                                  <join 0>
                                                                = let {
                                                                    cs :: ChessBoard.ColLoc
                                                                    = GHC.Types.I# ww1
                                                                  } in
                                                                  case ChessBoard.$wisValidMove
                                                                         wild3
                                                                         (ChessBoard.Location
                                                                            cs
                                                                            wild)
                                                                         (ChessBoard.Location
                                                                            wild1
                                                                            wild2)
                                                                         ww of ww5 { (#,#) ww6 ww7 ->
                                                                  case ww6 of wild4 {
                                                                    GHC.Types.False -> ww5
                                                                    GHC.Types.True
                                                                    -> case GHC.List.$w!!
                                                                              @ (GHC.Maybe.Maybe
                                                                                   ChessBoard.Piece)
                                                                              (GHC.List.$w!!
                                                                                 @ ChessBoard.Row
                                                                                 ww
                                                                                 x4)
                                                                              x3 of wild5 {
                                                                         GHC.Maybe.Nothing
                                                                         -> case ChessBoard.isKingInCheck
                                                                                   (ChessBoard.$wchangeBoard
                                                                                      (ChessBoard.$wchangeBoard
                                                                                         ww
                                                                                         (GHC.Maybe.Nothing
                                                                                            @ ChessBoard.Piece)
                                                                                         cs
                                                                                         x2)
                                                                                      (GHC.List.$w!!
                                                                                         @ (GHC.Maybe.Maybe
                                                                                              ChessBoard.Piece)
                                                                                         (GHC.List.$w!!
                                                                                            @ ChessBoard.Row
                                                                                            ww
                                                                                            x2)
                                                                                         ww1)
                                                                                      (GHC.Types.I#
                                                                                         x3)
                                                                                      x4)
                                                                                   w of wild6 {
                                                                              GHC.Types.False
                                                                              -> (# GHC.Types.True,
                                                                                    GHC.Maybe.Nothing
                                                                                      @ GHC.Base.String #)
                                                                              GHC.Types.True
                                                                              -> (# GHC.Types.False,
                                                                                    ChessBoard.isValidPlayerMove7 #) }
                                                                         GHC.Maybe.Just a1
                                                                         -> case ChessBoard.isKingInCheck
                                                                                   (ChessBoard.$wchangeBoard
                                                                                      (ChessBoard.$wchangeBoard
                                                                                         ww
                                                                                         (GHC.Maybe.Nothing
                                                                                            @ ChessBoard.Piece)
                                                                                         cs
                                                                                         x2)
                                                                                      (GHC.List.$w!!
                                                                                         @ (GHC.Maybe.Maybe
                                                                                              ChessBoard.Piece)
                                                                                         (GHC.List.$w!!
                                                                                            @ ChessBoard.Row
                                                                                            ww
                                                                                            x2)
                                                                                         ww1)
                                                                                      (GHC.Types.I#
                                                                                         x3)
                                                                                      x4)
                                                                                   w of wild6 {
                                                                              GHC.Types.False
                                                                              -> (# GHC.Types.True,
                                                                                    GHC.Maybe.Nothing
                                                                                      @ GHC.Base.String #)
                                                                              GHC.Types.True
                                                                              -> (# GHC.Types.False,
                                                                                    ChessBoard.isValidPlayerMove7 #) } } } }
                                                              } in
                                                              case w of wild4 {
                                                                ChessBoard.Black
                                                                -> case ipv of wild5 { ChessBoard.Piece ds ds1 ->
                                                                   case ds of wild6 {
                                                                     ChessBoard.Black -> $j
                                                                     ChessBoard.White
                                                                     -> (# GHC.Types.False,
                                                                           ChessBoard.isValidPlayerMove10 #) } }
                                                                ChessBoard.White
                                                                -> case ipv of wild5 { ChessBoard.Piece ds ds1 ->
                                                                   case ds of wild6 {
                                                                     ChessBoard.Black
                                                                     -> (# GHC.Types.False,
                                                                           ChessBoard.isValidPlayerMove10 #)
                                                                     ChessBoard.White -> $j } } } }
                                                      1#
                                                      -> (# GHC.Types.False,
                                                            ChessBoard.isValidPlayerMove4 #) }
                                                 1#
                                                 -> (# GHC.Types.False,
                                                       ChessBoard.isValidPlayerMove4 #) }
                                            1#
                                            -> (# GHC.Types.False,
                                                  ChessBoard.isValidPlayerMove4 #) } }
                                       1#
                                       -> (# GHC.Types.False, ChessBoard.isValidPlayerMove4 #) } }
                                  1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }
                             1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }
                        1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) } }
                   1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }) -}
53f28c3411c0061a1a74d1a1a3026bb1
  $wisValidQueenMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),U(U)><S,U><S(S),U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case ww of ww4 { GHC.Types.I# ww5 ->
                     case ww2 of ww6 { GHC.Types.I# ww7 ->
                     case ChessBoard.$wisValidBishopMovement ww5 ww1 ww7 ww3 of wild {
                       GHC.Types.False
                       -> case GHC.Prim.==# ww3 ww1 of lwild {
                            DEFAULT
                            -> case GHC.Prim.-# ww3 ww1 of wild1 {
                                 DEFAULT
                                 -> case GHC.Prim.-# ww7 ww5 of wild2 {
                                      DEFAULT -> GHC.Types.False 0# -> GHC.Types.True }
                                 0# -> GHC.Types.True }
                            1#
                            -> case GHC.Prim.==# ww7 ww5 of lwild1 {
                                 DEFAULT
                                 -> case GHC.Prim.-# ww3 ww1 of wild1 {
                                      DEFAULT
                                      -> case GHC.Prim.-# ww7 ww5 of wild2 {
                                           DEFAULT -> GHC.Types.False 0# -> GHC.Types.True }
                                      0# -> GHC.Types.True }
                                 1# -> GHC.Types.False } }
                       GHC.Types.True -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
9f790fbc332a16ec74daf0ed95ab099f
  $wisValidRookMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U(U)><S,U><L,U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case GHC.Prim.-# ww3 ww1 of wild {
                       DEFAULT
                       -> case ww2 of wild1 { GHC.Types.I# x2 ->
                          case ww of wild2 { GHC.Types.I# y ->
                          case GHC.Prim.-# x2 y of wild3 {
                            DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } } }
                       0# -> GHC.Types.True }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
e1fe0d3ca9bd4b7925bcd4769ad04f11
  $wmovePiece ::
    ChessBoard.Board
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.Board
  {- Arity: 5, Strictness: <L,U><L,U(U)><L,U(U)><L,1*U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (ww :: ChessBoard.ColLoc)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 ChessBoard.$wchangeBoard
                   (case ww1 of ww4 { GHC.Types.I# ww5 ->
                    ChessBoard.$wchangeBoard
                      w
                      (GHC.Maybe.Nothing @ ChessBoard.Piece)
                      ww
                      ww5 })
                   (case ww of ww4 { GHC.Types.I# ww5 ->
                    case ww1 of ww6 { GHC.Types.I# ww7 ->
                    GHC.List.$w!!
                      @ (GHC.Maybe.Maybe ChessBoard.Piece)
                      (GHC.List.$w!! @ ChessBoard.Row w ww7)
                      ww5 } })
                   ww2
                   ww3) -}
d69a3a021266505dfb77d8af3b534ef7
  $wprintCol :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT -> ChessBoard.$fShowLocation16
                   0# -> ChessBoard.$fShowLocation14
                   1# -> ChessBoard.$fShowChessPiece9
                   2# -> ChessBoard.$fShowLocation12
                   3# -> ChessBoard.$fShowLocation10
                   4# -> ChessBoard.$fShowLocation8
                   5# -> ChessBoard.$fShowLocation6
                   6# -> ChessBoard.$fShowLocation4
                   7# -> ChessBoard.$fShowLocation2 }) -}
66be104038eeb203c413bfe9114d1865
  $wprintPlayerScore ::
    GHC.Base.String
    -> ChessBoard.Color -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   ChessBoard.printPlayerScore3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ww
                      (GHC.CString.unpackAppendCString#
                         ChessBoard.printPlayerScore2
                         (let {
                            n9 :: [GHC.Types.Char]
                            = GHC.CString.unpackAppendCString#
                                ChessBoard.printPlayerScore1
                                (case ww2 of ww3 { GHC.Types.I# ww4 ->
                                 case GHC.Show.$wshowSignedInt
                                        0#
                                        ww4
                                        (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                                 GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                          } in
                          case ww1 of wild {
                            ChessBoard.Black
                            -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece9 n9
                            ChessBoard.White
                            -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowColor2 n9 })))) -}
c8121ec4c6844a76bc77cca12da2fda5
  $wprintRow ::
    GHC.Prim.Int#
    -> ChessBoard.Board -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: ChessBoard.Board) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        (GHC.Prim.+# ww 1#)
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 case GHC.Base.++_$s++
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           ChessBoard.printBoard3
                           (case GHC.Base.map
                                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                   @ [GHC.Types.Char]
                                   ChessBoard.printMaybePiece
                                   (GHC.List.$w!! @ ChessBoard.Row w ww) of wild {
                              [] -> ChessBoard.printBoard1
                              : x2 xs
                              -> ChessBoard.printBoard_go1
                                   (GHC.Types.:
                                      @ GHC.Base.String
                                      x2
                                      (Data.OldList.prependToAll
                                         @ GHC.Base.String
                                         ChessBoard.colSep
                                         xs)) }))
                        ww5
                        ww6 of ww1 { : ww2 ww3 ->
                 (# ww2, ww3 #) } }) -}
0e967bd9fdd838310d9c3cc74eb35066
  $wprintScore ::
    GHC.Base.String
    -> ChessBoard.Color
    -> GHC.Types.Int
    -> ChessBoard.Player
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,1*U><L,1*U><L,1*U(U)><L,1*U(1*U,1*U,A,A,1*U(U))>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: ChessBoard.Player) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintPlayerScore ww ww1 ww2)
                   (GHC.CString.unpackAppendCString#
                      ChessBoard.printScore1
                      (case ww3 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                       ChessBoard.$wprintPlayerScore ww5 ww6 ww9 }))) -}
6839bed58a98b80bcab46aa9dcee5bca
  $wupdateActive ::
    GHC.Base.String
    -> ChessBoard.Color
    -> ChessBoard.Pieces
    -> ChessBoard.Pieces
    -> GHC.Types.Int
    -> ChessBoard.ChessPiece
    -> (# GHC.Base.String, ChessBoard.Color, ChessBoard.Pieces,
          ChessBoard.Pieces, GHC.Types.Int #)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: ChessBoard.Pieces)
                   (ww3 :: ChessBoard.Pieces)
                   (ww4 :: GHC.Types.Int)
                   (w :: ChessBoard.ChessPiece) ->
                 (# ww, ww1, ww2,
                    let {
                      exit :: ChessBoard.Pieces <join 0>
                      = ChessBoard.removePiece ww3 (GHC.Maybe.Nothing @ GHC.Types.Int)
                    } in
                    let {
                      exit1 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit2 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit3 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit4 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit5 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit6 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    letrec {
                      go1 :: [ChessBoard.ChessPiece]
                             -> GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                      = \ (ds :: [ChessBoard.ChessPiece]) (eta :: GHC.Prim.Int#) ->
                        case ds of wild {
                          [] -> exit
                          : y ys
                          -> case w of wild1 {
                               ChessBoard.Pawn
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Pawn -> exit1 eta }
                               ChessBoard.Bishop
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Bishop -> exit2 eta }
                               ChessBoard.Knight
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Knight -> exit3 eta }
                               ChessBoard.Rook
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Rook -> exit4 eta }
                               ChessBoard.Queen
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Queen -> exit5 eta }
                               ChessBoard.King
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.King -> exit6 eta } } }
                    } in
                    go1 ww3 0#,
                    ww4 #)) -}
4b67b52c4c3fa0d35893db32c54e1c52
  $wupdateBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (# ChessBoard.Board, GHC.Maybe.Maybe ChessBoard.Piece #)
  {- Arity: 4, Strictness: <S,U><L,1*U(U(U),U(U))><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row w ww1)
                        ww of wild {
                   GHC.Maybe.Nothing
                   -> (# case w1 of ww2 { ChessBoard.Location ww3 ww4 ->
                         ChessBoard.$wmovePiece w ww3 ww4 (GHC.Types.I# ww) ww1 },
                         GHC.Maybe.Nothing @ ChessBoard.Piece #)
                   GHC.Maybe.Just a1
                   -> (# case w1 of ww2 { ChessBoard.Location ww3 ww4 ->
                         ChessBoard.$wmovePiece w ww3 ww4 (GHC.Types.I# ww) ww1 },
                         wild #) }) -}
dd69b5fe4fb4f5eab5f03c8bbaf08244
  $wxs ::
    GHC.Prim.Int#
    -> (# ChessBoard.ChessPiece, [ChessBoard.ChessPiece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
5e130be897ac875a751b502fa938a30d
  $wxs1 ::
    GHC.Prim.Int#
    -> (# GHC.Maybe.Maybe ChessBoard.Piece,
          [GHC.Maybe.Maybe ChessBoard.Piece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
29a9c03c3ee1b063271727c6b1d4deb8
  $wxs2 ::
    GHC.Prim.Int#
    -> (# ChessBoard.ChessPiece, [ChessBoard.ChessPiece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
577092671970798aca5dfe73cd594681
  $wxs3 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
a80f7fb5a45a659392b7c155fbeb7f27
  type Board = [ChessBoard.Row]
a9339aa10bc82e16fb147d7654bbb4ff
  data ChessPiece = Pawn | Bishop | Knight | Rook | Queen | King
4d2f9eb496243069f6f7fa596bc08890
  type ColLoc = GHC.Types.Int
27801c70e04fd089bd52ac644edf6eba
  data Color = Black | White
8b7ec43a9e464f5e3a175896a8ca2ca2
  data Direction
    = Forward
    | Backward
    | Leftt
    | Rightt
    | DiagFR
    | DiagBR
    | DiagFL
    | DiagBL
7a011c4c9efc3cb6ff7b0b66496d2ceb
  data Game
    = Game {gameBoard :: ChessBoard.Board,
            gamePlayer1 :: ChessBoard.Player,
            gamePlayer2 :: ChessBoard.Player}
84ebeb4fb08dba347017ed67982bc062
  data GameOver = CheckMate | StaleMate | Unfinished
61763d609e56610dc321c7932fa09a95
  data Location = Location ChessBoard.ColLoc ChessBoard.RowLoc
c96a7f101a22e2b2d8fdf2cc4d7a27a9
  data Piece = Piece ChessBoard.Color ChessBoard.ChessPiece
fab35df16fb8e21f14678034b5f1d0d5
  type Pieces = [ChessBoard.ChessPiece]
8e056af4d83966ffb6cca0fdd40d0ace
  data Player
    = Player {name :: GHC.Base.String,
              playerColor :: ChessBoard.Color,
              captured :: ChessBoard.Pieces,
              active :: ChessBoard.Pieces,
              score :: GHC.Types.Int}
d1d9d77327d3bca4d6ac2ee7b57336fe
  type Row = [GHC.Maybe.Maybe ChessBoard.Piece]
4914dcb02a6fb8ad0fa41ddf9ab61abf
  type RowLoc = GHC.Types.Int
8e056af4d83966ffb6cca0fdd40d0ace
  active :: ChessBoard.Player -> ChessBoard.Pieces
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Player) ->
                 case ds of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ds4 }) -}
798b5538e6d188239629ca47726e9f33
  baseRow :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Rook
                   ChessBoard.baseRow1) -}
b846ebad8fb45b1eadbdfe0056d06cd9
  baseRow1 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Knight
                   ChessBoard.baseRow2) -}
cad59b42bce14734dcb5bb28816d7f95
  baseRow2 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Bishop
                   ChessBoard.baseRow3) -}
2fc098afd449a9a2aed6afda4b83e61c
  baseRow3 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Queen
                   ChessBoard.baseRow4) -}
9513705744908af2f3a02446d20836bb
  baseRow4 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.King
                   ChessBoard.baseRow5) -}
70161a71e966daa41b203a5cbb011a5b
  baseRow5 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Bishop
                   ChessBoard.baseRow6) -}
92a25d7f4e3ddc5fa6bf323f72b1a12f
  baseRow6 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Knight
                   ChessBoard.baseRow7) -}
fc2ecab8d55bdf1b8f9223f02ae8b051
  baseRow7 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Rook
                   (GHC.Types.[] @ ChessBoard.ChessPiece)) -}
8e237cda1d273d30528e8df95ef36c1d
  blackPlayer :: ChessBoard.Player
  {- Strictness: m,
     Unfolding: (ChessBoard.Player
                   ChessBoard.blackPlayer2
                   ChessBoard.Black
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   ChessBoard.blackPlayer1
                   ChessBoard.$fShowPlayer2) -}
893bb7bb5333c64fbabcaafad0aad7e8
  blackPlayer1 :: [ChessBoard.ChessPiece]
  {- Unfolding: (case ChessBoard.$wxs 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ ChessBoard.ChessPiece ww1 ww2 }) -}
2d11039024db7a7bbc9086cc1f7fdb08
  blackPlayer2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.blackPlayer3) -}
90df37657349ed2e53d2e56eecb960f5
  blackPlayer3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player 2"#) -}
8e056af4d83966ffb6cca0fdd40d0ace
  captured :: ChessBoard.Player -> ChessBoard.Pieces
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSLL),1*U(A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Player) ->
                 case ds of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ds3 }) -}
79547bc33606f085f369bc84f570a8e7
  changeBoard ::
    ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wchangeBoard w w1 w2 ww1 }) -}
57f2291bfcedc5f392a508c1b09e5e08
  checkPawnPromotion ::
    ChessBoard.Game
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(SLL),1*U(1*U,A,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(A,1*U(1*U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww6 of ww9 { GHC.Types.I# ww10 ->
                 case w2 of ww11 { ChessBoard.Location ww12 ww13 ->
                 ChessBoard.$wcheckPawnPromotion ww1 ww8 ww10 ww13 } } } } }) -}
01e52e1febd5ce79747e5d4fb6f73047
  checkPiece ::
    ChessBoard.Board
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 3, Strictness: <L,1*U><S(S),1*U(U)><L,1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.ColLoc)
                   (w2 :: ChessBoard.RowLoc) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wcheckPiece w ww1 w2 }) -}
d7b83b876abe145fd3f0a5323c6cb208
  colSep :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# ChessBoard.colSep1) -}
f1b16eb558d343a7d5e47b776da27e74
  colSep1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("|"#) -}
6887e000ec8bbe406477b702f683448a
  colorPiece ::
    ChessBoard.Color -> ChessBoard.ChessPiece -> ChessBoard.Piece
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True) ChessBoard.Piece -}
0e94493b0bcc83243b3a8937bdbacd53
  cycleBoardCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,1*U(U,A,A)><L,U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 ChessBoard.$wcycleBoardCheck w w1 ww1 ww3 } }) -}
01ebcef9272ee85faf64e684a5100a79
  cycleMoveCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <S(SLL),1*U(U,A,A)><L,U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 case w3 of ww6 { GHC.Types.I# ww7 ->
                 ChessBoard.$wcycleMoveCheck ww1 w1 ww5 ww7 } } }) -}
7930796f659c2cd7e0daf85c36b57a16
  emptyRow :: ChessBoard.Row
  {- Unfolding: (case ChessBoard.$wxs1 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Maybe.Maybe ChessBoard.Piece) ww1 ww2 }) -}
ead7c546815ef4c8c806cc864633e6a0
  firstPiece ::
    ChessBoard.Direction
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 4, Strictness: <L,U><S(S),1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Direction)
                   (w1 :: ChessBoard.ColLoc)
                   (w2 :: ChessBoard.RowLoc)
                   (w3 :: ChessBoard.Board) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wfirstPiece w ww1 w2 w3 }) -}
52d4e67708a3d71ec7cf96b63f10cd91
  fromPieceToChessPiece :: ChessBoard.Piece -> ChessBoard.ChessPiece
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Piece) ->
                 case ds of wild { ChessBoard.Piece ds1 cp -> cp }) -}
9f29bc6ebcae95dd9b4e3aaae39af9d1
  fromPieceToColor :: ChessBoard.Piece -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Piece) ->
                 case ds of wild { ChessBoard.Piece color ds1 -> color }) -}
9505daac119756ab54015b8a7a5b25aa
  game :: ChessBoard.Game
  {- Strictness: m,
     Unfolding: (ChessBoard.Game
                   ChessBoard.startBoard
                   ChessBoard.whitePlayer
                   ChessBoard.blackPlayer) -}
7a011c4c9efc3cb6ff7b0b66496d2ceb
  gameBoard :: ChessBoard.Game -> ChessBoard.Board
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Game) ->
                 case ds of wild { ChessBoard.Game ds1 ds2 ds3 -> ds1 }) -}
7a011c4c9efc3cb6ff7b0b66496d2ceb
  gamePlayer1 :: ChessBoard.Game -> ChessBoard.Player
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(A,1*U(U,U,U,U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Game) ->
                 case ds of wild { ChessBoard.Game ds1 ds2 ds3 -> ds2 }) -}
7a011c4c9efc3cb6ff7b0b66496d2ceb
  gamePlayer2 :: ChessBoard.Game -> ChessBoard.Player
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS),1*U(A,A,1*U(U,U,U,U,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Game) ->
                 case ds of wild { ChessBoard.Game ds1 ds2 ds3 -> ds3 }) -}
74887a82e4f729a8aaf8dd43c22a0fb3
  getKingInBoard ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 4, Strictness: <S,U><L,U><S(S),1*U(1*U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 ChessBoard.$wgetKingInBoard w w1 ww1 ww3 } }) -}
6b559fbfd9a5cd55225734ed013db4a0
  getKingLocation ::
    ChessBoard.Board
    -> ChessBoard.Color -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (board :: ChessBoard.Board) (color :: ChessBoard.Color) ->
                 ChessBoard.getKingInBoard
                   board
                   color
                   ChessBoard.$fShowPlayer2
                   ChessBoard.$fShowPlayer2) -}
d3d26c64bdaaed45360edb4cfd3c1f2f
  getNextCol ::
    ChessBoard.ColLoc -> ChessBoard.Direction -> ChessBoard.ColLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.ColLoc) (w1 :: ChessBoard.Direction) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of wild {
                   DEFAULT -> GHC.Types.I# ww1
                   ChessBoard.Leftt -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.Rightt -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagFR -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagBR -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagFL -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.DiagBL -> GHC.Types.I# (GHC.Prim.-# ww1 1#) } }) -}
d6a0e9185dd8e37b5e8138c394d25ea8
  getNextRow ::
    ChessBoard.RowLoc -> ChessBoard.Direction -> ChessBoard.RowLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.RowLoc) (w1 :: ChessBoard.Direction) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of wild {
                   DEFAULT -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.Backward -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.Leftt -> GHC.Types.I# ww1
                   ChessBoard.Rightt -> GHC.Types.I# ww1
                   ChessBoard.DiagBR -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.DiagBL -> GHC.Types.I# (GHC.Prim.-# ww1 1#) } }) -}
838b89a1794db19840c6e5690d0b3708
  isAnyBishopMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyBishopMove w w1 ww1 w3 }) -}
46331419b0e1df68c2bd00bfdfc4fdc3
  isAnyKingMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyKingMove ww1 w1 ww5 w3 } }) -}
2ad2db7bac0d0bb2d7dbf44ef14704fc
  isAnyKnightMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyKnightMove ww1 w1 ww5 w3 } }) -}
0a871db9719886dc061b77c4bbb073fd
  isAnyMove :: ChessBoard.Game -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (gm :: ChessBoard.Game) (color :: ChessBoard.Color) ->
                 ChessBoard.cycleBoardCheck
                   gm
                   color
                   ChessBoard.$fShowPlayer2
                   ChessBoard.$fShowPlayer2) -}
6e9a9ba840c5e9e9d51c68d37d550601
  isAnyMoveRecurse ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Direction
    -> GHC.Types.Bool
  {- Arity: 7,
     Strictness: <L,1*U(U,A,A)><L,U><L,1*U(U)><L,U(U)><S(S),1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc)
                   (w4 :: ChessBoard.ColLoc)
                   (w5 :: ChessBoard.RowLoc)
                   (w6 :: ChessBoard.Direction) ->
                 case w4 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyMoveRecurse w w1 w2 w3 ww1 w5 w6 }) -}
875149a10d88d8597f48659959bd15e3
  isAnyPawnMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyPawnMove ww1 w1 ww5 w3 } }) -}
027c90c5b243aa6397c1329c97477f3f
  isAnyQueenMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyQueenMove w w1 ww1 w3 }) -}
9b4d7c864cfb56d1eb2975efa8db35c4
  isAnyRookMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyRookMove w w1 ww1 w3 }) -}
4c9d76c38c4c171188f85b094993a9f4
  isClearPath ::
    ChessBoard.Location
    -> ChessBoard.Location -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Location)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisClearPath ww4 ww6 ww11 ww13 w2 } } } } } }) -}
15908479c440767eafbca1eb00d94f4d
  isEnemyPiece ::
    ChessBoard.Color
    -> GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: ChessBoard.Color)
                   (ds1 :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just ds2
                   -> case ds2 of wild1 { ChessBoard.Piece enemyColor ds3 ->
                      ChessBoard.$fEqColor_$c/= ds enemyColor } }) -}
eaeb8ae20141c59f190bbacfca7eebaf
  isGameOver ::
    ChessBoard.Game -> ChessBoard.Color -> ChessBoard.GameOver
  {- Arity: 2, Strictness: <S(SLL),1*U(U,A,A)><L,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Game) (w1 :: ChessBoard.Color) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 ChessBoard.$wisGameOver ww1 w1 }) -}
e0d5ead2f76121dfc0bfb008656e887d
  isGameOver1 :: ChessBoard.Player
  {- Unfolding: (Control.Exception.Base.absentError
                   @ ChessBoard.Player
                   ChessBoard.isGameOver2) -}
7f8e315ab1573ce95f4edd640f16b7fd
  isGameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww Player"#) -}
e0fc2359cd374be59d4683994dfa6014
  isKingInCheck ::
    ChessBoard.Board -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (board :: ChessBoard.Board)
                   (turn :: ChessBoard.Color) ->
                 let {
                   kingLoc :: GHC.Maybe.Maybe ChessBoard.Location
                   = ChessBoard.$wgetKingInBoard board turn 0# 0#
                 } in
                 case ChessBoard.isKingInDiagCheck kingLoc turn board of wild {
                   GHC.Types.False
                   -> case ChessBoard.isKingInStraightCheck
                             kingLoc
                             turn
                             board of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.isKingInKnightCheck
                                  kingLoc
                                  turn
                                  board of wild2 {
                             GHC.Types.False
                             -> case ChessBoard.isKingInPawnCheck kingLoc turn board of wild3 {
                                  GHC.Types.False -> ChessBoard.isKingInKingCheck kingLoc turn board
                                  GHC.Types.True -> GHC.Types.True }
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
7a4587cd156d51950157b718cf44d8ca
  isKingInDiagCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
8df55979d4920be316c3f64833e15085
  isKingInKingCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
37930218ab3b60b8d2a7cd3d5b67b3b7
  isKingInKnightCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
8ce412682e05e98f47a84f043b6317a3
  isKingInPawnCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
de21611eb4997092a58ded9694d31752
  isKingInStraightCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
c5fbf661e38233edf262ad17bfc6c28c
  isKingLeftInCheck ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <S,U><L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (board :: ChessBoard.Board)
                   (ls :: ChessBoard.Location)
                   (le :: ChessBoard.Location)
                   (turnColor :: ChessBoard.Color) ->
                 case ChessBoard.updateBoard board ls le of wild { (,) x2 ds1 ->
                 ChessBoard.isKingInCheck x2 turnColor }) -}
2ce39f9b970fd94e223be9f6a487a04d
  isOpen :: ChessBoard.Location -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 ChessBoard.$wisOpen ww4 ww6 w1 } } }) -}
0565781b4506b4ae6844a79efed3e46e
  isValidBishopMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case ww5 of ww8 { GHC.Types.I# ww9 ->
                 case w2 of ww10 { ChessBoard.Location ww11 ww12 ->
                 case ww11 of ww13 { GHC.Types.I# ww14 ->
                 case ww12 of ww15 { GHC.Types.I# ww16 ->
                 case ChessBoard.$wisValidBishopMovement ww7 ww9 ww14 ww16 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove7)
                   GHC.Types.True
                   -> case ChessBoard.$wisClearPath ww7 ww9 ww14 ww16 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                       ww14 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds
                                  -> case ds of wild4 { ChessBoard.Piece enemyColor ds1 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
3a4f6db0fe1ed6c950978996af39e536
  isValidBishopMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove2) -}
2c4b419c012464698b163cdf2e0aef69
  isValidBishopMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove3) -}
c626ec92e49e09d0dbadc10fca88559e
  isValidBishopMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("You cannot capture your own piece!"#) -}
de6282dac4e95dba895e0de4aba3aa6f
  isValidBishopMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove5) -}
dc41b8e308f79a8e4f8a1c3266957fb5
  isValidBishopMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove6) -}
cf4e4806bcd8233e4f52e5ebc5efd121
  isValidBishopMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("The path is not clear!"#) -}
a97fa64fc73172f1e4e58501bbbb1546
  isValidBishopMove7 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove8) -}
62af27b63aa86c9b500b3aab7682bd98
  isValidBishopMove8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove9) -}
f6802b2985120708884f1928a20e1dfa
  isValidBishopMove9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid bishop movement!"#) -}
c00f65d60dac9d606189cb1dd2a0c582
  isValidBishopMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidBishopMovement
                   ww4
                   ww6
                   ww11
                   ww13 } } } } } }) -}
319d71074ba7a21d22dc2356b1088230
  isValidKingMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case ww5 of ww8 { GHC.Types.I# ww9 ->
                 case w2 of ww10 { ChessBoard.Location ww11 ww12 ->
                 case ww11 of ww13 { GHC.Types.I# ww14 ->
                 case ww12 of ww15 { GHC.Types.I# ww16 ->
                 case ChessBoard.$wisValidKingMovement ww7 ww9 ww14 ww16 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidKingMove1)
                   GHC.Types.True
                   -> case GHC.List.$w!!
                             @ (GHC.Maybe.Maybe ChessBoard.Piece)
                             (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                             ww14 of wild1 {
                        GHC.Maybe.Nothing
                        -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                        GHC.Maybe.Just a1
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                             GHC.Maybe.Just ds
                             -> case ds of wild3 { ChessBoard.Piece enemyColor ds1 ->
                                case ww1 of wild4 {
                                  ChessBoard.Black
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                       ChessBoard.White
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                                  ChessBoard.White
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                       ChessBoard.White
                                       -> (GHC.Types.False,
                                           ChessBoard.isValidBishopMove1) } } } } } } } } } } } } }) -}
93bab132f5a7287b49ea330c33e4f73a
  isValidKingMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidKingMove2) -}
1c1065190960b503a5b59c12e79ef2b6
  isValidKingMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidKingMove3) -}
4b301e03fba4a065ac8f9f2904c4c46d
  isValidKingMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid king movement!"#) -}
3ef8bbd2d6476991c504d257899b074d
  isValidKingMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidKingMovement ww4 ww6 ww11 ww13 } } } } } }) -}
46d48ed1ab93e3b2ef1d2ce678d0ba40
  isValidKnightMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidKnightMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidKnightMove1)
                   GHC.Types.True
                   -> case ww9 of ww13 { GHC.Types.I# ww14 ->
                      case GHC.List.$w!!
                             @ (GHC.Maybe.Maybe ChessBoard.Piece)
                             (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                             ww14 of wild1 {
                        GHC.Maybe.Nothing
                        -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                        GHC.Maybe.Just a1
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                             GHC.Maybe.Just ds
                             -> case ds of wild3 { ChessBoard.Piece enemyColor ds1 ->
                                case ww1 of wild4 {
                                  ChessBoard.Black
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                       ChessBoard.White
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                                  ChessBoard.White
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                       ChessBoard.White
                                       -> (GHC.Types.False,
                                           ChessBoard.isValidBishopMove1) } } } } } } } } } } } }) -}
cdb33a54e1e6f1221663094fa85aab51
  isValidKnightMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidKnightMove2) -}
412e5d8d48afcaebddb8a0be766efa9a
  isValidKnightMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidKnightMove3) -}
fd83a6175072c92b7967a0188ee5f485
  isValidKnightMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid knight movement!"#) -}
3a5da5b76a45b23239c0b554ffb17784
  isValidKnightMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidKnightMovement ww1 ww4 ww6 ww9 } } } }) -}
c101d00aa0d44678a420e5ab3c1f3944
  isValidMove ::
    GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U><L,1*U(U(U),U(U))><L,1*U(U(U),U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case ChessBoard.$wisValidMove w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
b51c799a39ae66096ff217d2e76326e7
  isValidMoveColor ::
    ChessBoard.Color
    -> GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (ds :: ChessBoard.Color)
                   (ds1 :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just ipv
                   -> case ds of wild1 {
                        ChessBoard.Black
                        -> case ipv of wild2 { ChessBoard.Piece ds2 ds3 ->
                           case ds2 of wild3 {
                             ChessBoard.Black -> GHC.Types.True
                             ChessBoard.White -> GHC.Types.False } }
                        ChessBoard.White
                        -> case ipv of wild2 { ChessBoard.Piece ds2 ds3 ->
                           case ds2 of wild3 {
                             ChessBoard.Black -> GHC.Types.False
                             ChessBoard.White -> GHC.Types.True } } } }) -}
5c00632c04314172bd41db686686e78c
  isValidMovement ::
    ChessBoard.Piece
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,1*U)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 ChessBoard.$wisValidMovement ww1 ww2 ww4 ww7 ww9 ww12 } } } } }) -}
680dc5043b6616b5acfce6a7a89c0bf0
  isValidMovementPiece ::
    ChessBoard.Piece
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,1*U)><S(S(S)L),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w2 of ww5 { ChessBoard.Location ww6 ww7 ->
                 ChessBoard.$wisValidMovementPiece w ww4 ww2 ww6 ww7 } } }) -}
e450c53a05c6665914ed891d507be701
  isValidPawnAttack ::
    ChessBoard.Color
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U><S(S(S)L),1*U(1*U(U),U(U))><S(S(S)L),1*U(1*U(U),U(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Color)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w2 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidPawnAttack w ww4 ww2 ww9 ww7 w3 } } } }) -}
dbf7bb99bee99e6e5000ce29e53106bb
  isValidPawnMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(U,A)><S(S(S)L),1*U(1*U(U),U(U))><S(S(S)L),1*U(1*U(U),U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww9 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidPawnAttack
                        ww1
                        ww7
                        ww5
                        ww12
                        ww10
                        w3 of wild {
                   GHC.Types.False
                   -> case ww5 of ww13 { GHC.Types.I# ww14 ->
                      case ww10 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisValidPawnMovement
                             ww1
                             ww7
                             ww14
                             ww12
                             ww16 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidPawnMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww12 of wild2 {
                             GHC.Maybe.Nothing
                             -> case ChessBoard.$wisClearPath ww7 ww14 ww12 ww16 w3 of wild3 {
                                  GHC.Types.False
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                                  GHC.Types.True
                                  -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                             GHC.Maybe.Just a1
                             -> (GHC.Types.False, ChessBoard.isValidPawnMove1) } } } }
                   GHC.Types.True
                   -> (GHC.Types.True,
                       GHC.Maybe.Nothing @ GHC.Base.String) } } } } } }) -}
140cd16bd3073140d24967323eef5403
  isValidPawnMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPawnMove2) -}
07a29e2113a7167b0b7f84f4ade686cf
  isValidPawnMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPawnMove3) -}
c1c05996bdb88a375c2610a94003aaa9
  isValidPawnMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Location is not open!"#) -}
7a20eb28e0a13a28ee51e8c7efb43baa
  isValidPawnMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPawnMove5) -}
7ca756ab78df4f8dc26f2af1bbd5cea5
  isValidPawnMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPawnMove6) -}
3c256e57ba35df0b6a95ec307798e863
  isValidPawnMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid pawn movement!"#) -}
af2392590afafbd06cf008114266801d
  isValidPawnMovement ::
    ChessBoard.Color
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Color)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w2 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidPawnMovement
                   w
                   ww4
                   ww6
                   ww11
                   ww13 } } } } } }) -}
1b6273c7a7a1d987a2919aa57175e2cb
  isValidPlayerMove ::
    ChessBoard.Game
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(U,A,A)><S(S(S)L),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Color) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w2 of ww9 { ChessBoard.Location ww10 ww11 ->
                 case ChessBoard.$wisValidPlayerMove
                        ww1
                        ww8
                        ww6
                        ww10
                        ww11
                        w3 of ww12 { (#,#) ww13 ww14 ->
                 (ww13, ww14) } } } } }) -}
2f6d4fe241a13f78d2cc115de3ac034f
  isValidPlayerMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove2) -}
5e1309924ce9a71fdaf0dbf198293e09
  isValidPlayerMove10 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove11) -}
237724a4220f363d3587c7b8c6ac45fa
  isValidPlayerMove11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove12) -}
c88e1882a8c6a30bafda00b3d36ee8cb
  isValidPlayerMove12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not your piece!"#) -}
c203c0cc8cc3038f66a1beecf5d1a63a
  isValidPlayerMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove3) -}
435a6edf2aed94ea25ea46d9c91d8081
  isValidPlayerMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid starting position"#) -}
c8f9d15740e4c9255bd649c853de5932
  isValidPlayerMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove5) -}
1520bb50d7c7daac37e5a5920f9ce53b
  isValidPlayerMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove6) -}
26abc1b442d88bae78b804d4c3352807
  isValidPlayerMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid ending position"#) -}
ac999bfcd9c1fb60675de761e416ccc6
  isValidPlayerMove7 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove8) -}
84c5b7261e1dd77b01d714e3827ceb69
  isValidPlayerMove8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove9) -}
e75516c341f8a51b87a22876fe58a1b7
  isValidPlayerMove9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Your King is left in Check!"#) -}
b00681114cdc1168e30ac3a178a15cec
  isValidQueenMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(U(U),1*U(U))><S(S(S)S(S)),1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidQueenMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidQueenMove1)
                   GHC.Types.True
                   -> case ww4 of ww13 { GHC.Types.I# ww14 ->
                      case ww9 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisClearPath ww14 ww7 ww16 ww12 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww16 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                       ww16 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds
                                  -> case ds of wild4 { ChessBoard.Piece enemyColor ds1 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
5ede98436cdc3a9b68da9e278ac87306
  isValidQueenMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidQueenMove2) -}
10b7c15b2c9533a8129ee8f20bc44997
  isValidQueenMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidQueenMove3) -}
87fabd1ac7997565dec2267d603e83b4
  isValidQueenMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid Queen movement!"#) -}
5dac95d48cd9db5916a7ad30b843295e
  isValidQueenMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(U(U),1*U(U))><S(S(S)S(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidQueenMovement ww1 ww4 ww6 ww9 } } } }) -}
bc34a46e97c41ce953eacf78278fef3e
  isValidRookMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidRookMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidRookMove1)
                   GHC.Types.True
                   -> case ww4 of ww13 { GHC.Types.I# ww14 ->
                      case ww9 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisClearPath ww14 ww7 ww16 ww12 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww16 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                       ww16 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds
                                  -> case ds of wild4 { ChessBoard.Piece enemyColor ds1 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
c72160f34fd28329d1b1b2a467a26fa1
  isValidRookMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidRookMove2) -}
efd2894f5ba28bcd962b5734784636d2
  isValidRookMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidRookMove3) -}
0c37c0626835c59346b41bef0672388e
  isValidRookMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid rook movement!"#) -}
77bbb878e4501e0c26bc791a2a9b8f75
  isValidRookMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidRookMovement ww1 ww4 ww6 ww9 } } } }) -}
50f9d1f952425353c184bf236b72842a
  location ::
    ChessBoard.ColLoc -> ChessBoard.RowLoc -> ChessBoard.Location
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True) ChessBoard.Location -}
09386c93f54b83194750c89cc3b8d45d
  mkDiagLocs ::
    [GHC.Types.Int] -> [GHC.Types.Int] -> [ChessBoard.Location]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
196bddf6b9ca8458da8c29e7159fe109
  movePiece ::
    ChessBoard.Board
    -> ChessBoard.Location -> ChessBoard.Location -> ChessBoard.Board
  {- Arity: 3,
     Strictness: <L,U><S,1*U(U(U),U(U))><S(LS(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case w2 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 ChessBoard.$wmovePiece w ww1 ww2 ww4 ww7 } } }) -}
8e056af4d83966ffb6cca0fdd40d0ace
  name :: ChessBoard.Player -> GHC.Base.String
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLLL),1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Player) ->
                 case ds of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ds1 }) -}
f82e69e040e75cc3ea61d06e029fb522
  notColor :: ChessBoard.Color -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Color) ->
                 case ds of wild {
                   ChessBoard.Black -> ChessBoard.White
                   ChessBoard.White -> ChessBoard.Black }) -}
9e5a953d6a2d236870c28b39f029d1c7
  pawnRow :: [ChessBoard.ChessPiece]
  {- Unfolding: (case ChessBoard.$wxs2 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ ChessBoard.ChessPiece ww1 ww2 }) -}
7e21c75cdbb3640536f5cfcff7863bb8
  pieceValue :: ChessBoard.ChessPiece -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.ChessPiece) ->
                 case ds of wild {
                   ChessBoard.Pawn -> ChessBoard.pieceValue5
                   ChessBoard.Bishop -> ChessBoard.pieceValue4
                   ChessBoard.Knight -> ChessBoard.pieceValue4
                   ChessBoard.Rook -> ChessBoard.pieceValue3
                   ChessBoard.Queen -> ChessBoard.pieceValue2
                   ChessBoard.King -> ChessBoard.pieceValue1 }) -}
79b1dd6b134131fdd0311d520fce12c4
  pieceValue1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 10#) -}
4325ea528983c89cfb18218239e0131a
  pieceValue2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 9#) -}
dc8332798325262e5645227b80717b58
  pieceValue3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5#) -}
f0d0131a6da1fa43ea926a5aebbc8e86
  pieceValue4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
377d08f0edbd5acb11d087de03caff35
  pieceValue5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
8e056af4d83966ffb6cca0fdd40d0ace
  playerColor :: ChessBoard.Player -> ChessBoard.Color
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Player) ->
                 case ds of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ds2 }) -}
3ba9f94d9a7388bc9c758727ba5cfe4a
  printBoard :: ChessBoard.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (board :: ChessBoard.Board) ->
                 GHC.CString.unpackAppendCString#
                   ChessBoard.printBoard4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ChessBoard.rowSep
                      (letrec {
                         go1 :: GHC.Prim.Int# -> [GHC.Base.String]
                           {- Arity: 1, Strictness: <L,U> -}
                         = \ (x2 :: GHC.Prim.Int#) ->
                           GHC.Types.:
                             @ GHC.Base.String
                             (case ChessBoard.$wprintRow x2 board of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ GHC.Types.Char ww1 ww2 })
                             (case x2 of wild {
                                DEFAULT -> go1 (GHC.Prim.+# wild 1#)
                                7# -> GHC.Types.[] @ GHC.Base.String })
                       } in
                       case go1 0# of wild {
                         [] -> ChessBoard.rowSep
                         : x2 xs
                         -> ChessBoard.printBoard_go
                              (GHC.Types.:
                                 @ GHC.Base.String
                                 x2
                                 (Data.OldList.prependToAll
                                    @ GHC.Base.String
                                    ChessBoard.rowSep
                                    xs)) }))) -}
3e29641befad27edc4aba0e4497c1bf8
  printBoard1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.printBoard2) -}
66442d5acda6985b9e6c66336c147c95
  printBoard2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("|\n"#) -}
411f6e5f17b366941b0357b81c40d3d9
  printBoard3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" |"#) -}
6e8fd4ae12678123017f854f4fe77527
  printBoard4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("   A  B  C  D  E  F  G  H  \n"#) -}
55b2193e453f49a665b2a8672daf1a94
  printBoard_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
601958c93246d2d8fde1b3e438010f76
  printBoard_go1 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
e5ce9d43eb1e4adb5c817e877c0b7341
  printCol :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> ChessBoard.$wprintCol ww1 }) -}
49831bd31a7e82c6c6e6aee4b6fc2ab3
  printMaybePiece ::
    GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds of wild {
                   GHC.Maybe.Nothing -> ChessBoard.printMaybePiece1
                   GHC.Maybe.Just ds1
                   -> case ds1 of wild1 { ChessBoard.Piece c cp ->
                      ChessBoard.printPiece c cp } }) -}
cc951904d4237b23b88e9bc9ae4c214b
  printMaybePiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.printMaybePiece2) -}
6410c85e180d5fc8f4bbdae6d2b0c00d
  printMaybePiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  "#) -}
c6248587e828c5597007c6ed8f3548fb
  printPiece ::
    ChessBoard.Color -> ChessBoard.ChessPiece -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (c :: ChessBoard.Color)
                   (cp :: ChessBoard.ChessPiece) ->
                 case c of wild {
                   ChessBoard.Black
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowChessPiece9
                        (case cp of wild1 {
                           ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                           ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                           ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                           ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                           ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                           ChessBoard.King -> ChessBoard.$fShowChessPiece1 })
                   ChessBoard.White
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowColor2
                        (case cp of wild1 {
                           ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                           ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                           ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                           ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                           ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                           ChessBoard.King -> ChessBoard.$fShowChessPiece1 }) }) -}
8acdce663679723ef823bb289e107124
  printPlayerScore :: ChessBoard.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,A,A,1*U(U))>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Player) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 ChessBoard.$wprintPlayerScore ww1 ww2 ww5 }) -}
6a3b8df024d486ee7274504b511d6950
  printPlayerScore1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" has score: "#) -}
e0da6234180f99ce79bce1cdf91e55df
  printPlayerScore2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" using "#) -}
1467be29efa34506c661b9f158665bb7
  printPlayerScore3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player "#) -}
f9d827f0f76c2d83086dfd701806afe6
  printRow ::
    ChessBoard.RowLoc -> ChessBoard.Board -> GHC.Base.String
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.RowLoc) (w1 :: ChessBoard.Board) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case ChessBoard.$wprintRow ww1 w1 of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ GHC.Types.Char ww3 ww4 } }) -}
d8d78ae752dbb7393e44d15251232672
  printScore :: ChessBoard.Game -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S(LSL),1*U(A,1*U(1*U,1*U,A,A,1*U(U)),1*U(1*U,1*U,A,A,1*U(U)))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Game) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case ww2 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                 ChessBoard.$wprintScore ww5 ww6 ww9 ww3 } }) -}
66c97400b77b3b20c5afbb463e148830
  printScore1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
c991e6f3905ca0d451262342f1e59d59
  promotePawn ::
    ChessBoard.Game
    -> ChessBoard.Location -> ChessBoard.ChessPiece -> ChessBoard.Game
  {- Arity: 3, Strictness: <S,1*U(U,U,U)><S,1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.ChessPiece) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 ChessBoard.Game
                   (case ww6 of ww7 { GHC.Types.I# ww8 ->
                    ChessBoard.$wchangeBoard
                      ww1
                      (GHC.Maybe.Just
                         @ ChessBoard.Piece
                         (ChessBoard.Piece
                            (case ww5 of ww9 { GHC.Types.I# ww10 ->
                             case GHC.List.$w!!
                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                    (GHC.List.$w!! @ ChessBoard.Row ww1 ww8)
                                    ww10 of wild {
                               GHC.Maybe.Nothing
                               -> case Data.Maybe.fromJust1 ret_ty ChessBoard.Color of {}
                               GHC.Maybe.Just x2
                               -> case x2 of wild1 { ChessBoard.Piece color ds -> color } } })
                            w2))
                      ww5
                      ww8 })
                   ww2
                   ww3 } }) -}
58632cbaee052ba9bf28f20b874e61bd
  promotePawnBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.Board
  {- Arity: 4,
     Strictness: <L,U><S(LS(S)),1*U(1*U(U),1*U(U))><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (board :: ChessBoard.Board)
                   (ds :: ChessBoard.Location)
                   (color :: ChessBoard.Color)
                   (cp :: ChessBoard.ChessPiece) ->
                 case ds of wild { ChessBoard.Location col row ->
                 ChessBoard.changeBoard
                   board
                   (GHC.Maybe.Just @ ChessBoard.Piece (ChessBoard.Piece color cp))
                   col
                   row }) -}
d1d901e863ff4c214f13546a401fab69
  removePiece ::
    [ChessBoard.ChessPiece]
    -> GHC.Maybe.Maybe GHC.Types.Int -> [ChessBoard.ChessPiece]
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (listPieces :: [ChessBoard.ChessPiece])
                   (index :: GHC.Maybe.Maybe GHC.Types.Int) ->
                 case index of wild {
                   GHC.Maybe.Nothing -> listPieces
                   GHC.Maybe.Just a1
                   -> case a1 of wild1 { GHC.Types.I# x2 ->
                      case GHC.Prim.<=# x2 0# of lwild {
                        DEFAULT
                        -> case listPieces of wild2 {
                             [] -> ChessBoard.removePiece1
                             : ipv ipv1
                             -> case x2 of ds1 {
                                  DEFAULT
                                  -> let {
                                       ds2 :: ([ChessBoard.ChessPiece], [ChessBoard.ChessPiece])
                                       = case GHC.List.splitAt_$s$wsplitAt'
                                                @ ChessBoard.ChessPiece
                                                ipv1
                                                (GHC.Prim.-# ds1 1#) of ww { (#,#) ww1 ww2 ->
                                         (ww1, ww2) }
                                     } in
                                     GHC.Base.++_$s++
                                       @ ChessBoard.ChessPiece
                                       (case ds2 of wild3 { (,) xs' xs'' ->
                                        case xs'' of wild4 {
                                          [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                          : ds4 xs -> xs } })
                                       ipv
                                       (case ds2 of wild3 { (,) xs' xs'' -> xs' })
                                  1#
                                  -> GHC.Base.++_$s++
                                       @ ChessBoard.ChessPiece
                                       (case ipv1 of wild3 {
                                          [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                          : ds2 xs -> xs })
                                       ipv
                                       (GHC.Types.[] @ ChessBoard.ChessPiece) } }
                        1#
                        -> GHC.Base.++
                             @ ChessBoard.ChessPiece
                             (GHC.Types.[] @ ChessBoard.ChessPiece)
                             (case listPieces of wild2 {
                                [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                : ds1 xs -> xs }) } } }) -}
9fdc5d9d42a2ddb9487c8a9087b7b6b0
  removePiece1 :: [ChessBoard.ChessPiece]
  {- Unfolding: (GHC.Base.++
                   @ ChessBoard.ChessPiece
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   (GHC.List.scanl2 @ ChessBoard.ChessPiece)) -}
60c025530bcbcd80596bae71478ba43c
  rowSep :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   ChessBoard.printMaybePiece2
                   ChessBoard.rowSep1) -}
63578eb5be6cb2b7a1b2ddeaa3701ae5
  rowSep1 :: [GHC.Types.Char]
  {- Unfolding: (ChessBoard.$wxs3 8#) -}
8e056af4d83966ffb6cca0fdd40d0ace
  score :: ChessBoard.Player -> GHC.Types.Int
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLS),1*U(A,A,A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Player) ->
                 case ds of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ds5 }) -}
02e1d57bf48531ee8bd36d2fd2d7f584
  startBoard :: ChessBoard.Board
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard13
                   ChessBoard.startBoard1) -}
966d82b44d24b941cb5d816152439d6d
  startBoard1 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard11
                   ChessBoard.startBoard2) -}
ad220b728e8c4938845f9c2bb75533fd
  startBoard10 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard9
                   ChessBoard.pawnRow) -}
781e57c630b140d24ac8638272518529
  startBoard11 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard12
                   ChessBoard.pawnRow) -}
b2d0602ef7a2c48f96879eca89631cd0
  startBoard12 ::
    ChessBoard.ChessPiece -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: (\ (x2 :: ChessBoard.ChessPiece) ->
                 GHC.Maybe.Just
                   @ ChessBoard.Piece
                   (ChessBoard.Piece ChessBoard.White x2)) -}
ad8a961eb272336e078da0407e43e31b
  startBoard13 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard12
                   ChessBoard.baseRow) -}
9554462903b4c1e959db29b103a52bd1
  startBoard2 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard3) -}
3b658c235bc318be72dcbe8377eee183
  startBoard3 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard4) -}
2fdf46db937ae4479552c24007875e87
  startBoard4 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard5) -}
4ab503183d72cccf2df1c18766a31b9a
  startBoard5 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard6) -}
6f22e9529006a77920515a58eab68c6d
  startBoard6 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard10
                   ChessBoard.startBoard7) -}
2b2312ccb5dab49d50c34559f02188f6
  startBoard7 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard8
                   (GHC.Types.[] @ ChessBoard.Row)) -}
b38974cffb2289bc3d1115c956811a24
  startBoard8 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard9
                   ChessBoard.baseRow) -}
b2dc05d72afbbdf4eb79734b62070656
  startBoard9 ::
    ChessBoard.ChessPiece -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: (\ (x2 :: ChessBoard.ChessPiece) ->
                 GHC.Maybe.Just
                   @ ChessBoard.Piece
                   (ChessBoard.Piece ChessBoard.Black x2)) -}
5bd60f4dc1e666c76efa0f49dc869fc4
  swapLoc :: ChessBoard.Location -> ChessBoard.Location
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ChessBoard.Location) ->
                 case ds of wild { ChessBoard.Location col row ->
                 ChessBoard.Location row col }) -}
58967aae67491883767de3e2e249f090
  turnToColor :: GHC.Types.Int -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# ds1 ->
                 case ds1 of ds2 {
                   DEFAULT -> ChessBoard.Black 1# -> ChessBoard.White } }) -}
a2c5b2e585a4df6e666a17965ca96ea7
  updateActive ::
    ChessBoard.Player -> ChessBoard.ChessPiece -> ChessBoard.Player
  {- Arity: 2, Strictness: <S,1*U(U,U,U,U,U)><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Player) (w1 :: ChessBoard.ChessPiece) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 case ChessBoard.$wupdateActive
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        w1 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 ChessBoard.Player ww7 ww8 ww9 ww10 ww11 } }) -}
78839e84f1cc7fcc65c01d3dbfad07d4
  updateBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> (ChessBoard.Board, GHC.Maybe.Maybe ChessBoard.Piece)
  {- Arity: 3,
     Strictness: <S,U><L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w2 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ChessBoard.$wupdateBoard
                        w
                        w1
                        ww4
                        ww6 of ww7 { (#,#) ww8 ww9 ->
                 (ww8, ww9) } } } }) -}
75af6457d224d9ca63d6397f24e80093
  updateCaptured ::
    ChessBoard.Player -> ChessBoard.ChessPiece -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (cp :: ChessBoard.ChessPiece) ->
                 case p of wild { ChessBoard.Player ds ds1 ds2 ds3 ds4 ->
                 ChessBoard.Player
                   ds
                   ds1
                   (GHC.Types.: @ ChessBoard.ChessPiece cp ds2)
                   ds3
                   ds4 }) -}
5ae8de6b28f7b817024b53ae02c29039
  updateGameBoard ::
    ChessBoard.Game -> ChessBoard.Board -> ChessBoard.Game
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (g :: ChessBoard.Game) (b :: ChessBoard.Board) ->
                 case g of wild { ChessBoard.Game ds ds1 ds2 ->
                 ChessBoard.Game b ds1 ds2 }) -}
c9527da6d325218f76284ec8120c4271
  updateGamePlayers ::
    ChessBoard.Game
    -> ChessBoard.Player -> ChessBoard.Player -> ChessBoard.Game
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U(U,A,A)><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (g :: ChessBoard.Game)
                   (p1 :: ChessBoard.Player)
                   (p2 :: ChessBoard.Player) ->
                 case g of wild { ChessBoard.Game ds ds1 ds2 ->
                 ChessBoard.Game ds p1 p2 }) -}
dcf32fd922c0fdd9f4c7d918337d20eb
  updatePlayerName ::
    ChessBoard.Player -> GHC.Base.String -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U,U,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (newname :: GHC.Base.String) ->
                 case p of wild { ChessBoard.Player ds ds1 ds2 ds3 ds4 ->
                 ChessBoard.Player newname ds1 ds2 ds3 ds4 }) -}
cb1351e0219826279df467a8d725406a
  updateScore ::
    ChessBoard.Player -> GHC.Types.Int -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,U,1*U(U))><L,1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (int :: GHC.Types.Int) ->
                 case p of wild { ChessBoard.Player ds ds1 ds2 ds3 ds4 ->
                 ChessBoard.Player
                   ds
                   ds1
                   ds2
                   ds3
                   (GHC.Num.$fNumInt_$c+ ds4 int) }) -}
29bcc25a12157d2e6701f2fd2a546792
  whitePlayer :: ChessBoard.Player
  {- Strictness: m,
     Unfolding: (ChessBoard.Player
                   ChessBoard.whitePlayer1
                   ChessBoard.White
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   ChessBoard.blackPlayer1
                   ChessBoard.$fShowPlayer2) -}
76ff9c76c0f4eafb4286f8340faa3f3d
  whitePlayer1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.whitePlayer2) -}
d90d4ce7c6cb43cf3f0808a0e098c253
  whitePlayer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player 1"#) -}
instance [safe] GHC.Classes.Eq [ChessBoard.ChessPiece]
  = ChessBoard.$fEqChessPiece
instance [safe] GHC.Classes.Eq [ChessBoard.Color]
  = ChessBoard.$fEqColor
instance [safe] GHC.Classes.Eq [ChessBoard.Direction]
  = ChessBoard.$fEqDirection
instance [safe] GHC.Classes.Eq [ChessBoard.GameOver]
  = ChessBoard.$fEqGameOver
instance [safe] GHC.Classes.Eq [ChessBoard.Piece]
  = ChessBoard.$fEqPiece
instance [safe] GHC.Show.Show [ChessBoard.ChessPiece]
  = ChessBoard.$fShowChessPiece
instance [safe] GHC.Show.Show [ChessBoard.Color]
  = ChessBoard.$fShowColor
instance [safe] GHC.Show.Show [ChessBoard.GameOver]
  = ChessBoard.$fShowGameOver
instance [safe] GHC.Show.Show [ChessBoard.Location]
  = ChessBoard.$fShowLocation
instance [safe] GHC.Show.Show [ChessBoard.Piece]
  = ChessBoard.$fShowPiece
instance [safe] GHC.Show.Show [ChessBoard.Player]
  = ChessBoard.$fShowPlayer
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

