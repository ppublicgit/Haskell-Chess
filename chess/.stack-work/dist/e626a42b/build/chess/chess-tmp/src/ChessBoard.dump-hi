
==================== FINAL INTERFACE ====================
2020-05-15 17:38:12.640473 UTC

interface main:ChessBoard 8065
  interface hash: 682a0b3a450fdac3a29e335cdcb89594
  ABI hash: 3f9b5483cd70d0a9ffc4a827b768dc8f
  export-list hash: c5512351b16360e77801c2cd12c1efd4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 60a29d9b0283457aa1b23a7b8469000f
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  ChessBoard.baseRow
  ChessBoard.blackPlayer
  ChessBoard.changeBoard
  ChessBoard.checkPawnPromotion
  ChessBoard.checkPiece
  ChessBoard.colSep
  ChessBoard.colorPiece
  ChessBoard.cycleBoardCheck
  ChessBoard.cycleMoveCheck
  ChessBoard.emptyRow
  ChessBoard.firstPiece
  ChessBoard.fromPieceToChessPiece
  ChessBoard.fromPieceToColor
  ChessBoard.game
  ChessBoard.getKingInBoard
  ChessBoard.getKingLocation
  ChessBoard.getNextCol
  ChessBoard.getNextRow
  ChessBoard.isAnyBishopMove
  ChessBoard.isAnyKingMove
  ChessBoard.isAnyKnightMove
  ChessBoard.isAnyMove
  ChessBoard.isAnyMoveRecurse
  ChessBoard.isAnyPawnMove
  ChessBoard.isAnyQueenMove
  ChessBoard.isAnyRookMove
  ChessBoard.isClearPath
  ChessBoard.isEnemyPiece
  ChessBoard.isGameOver
  ChessBoard.isKingInCheck
  ChessBoard.isKingInDiagCheck
  ChessBoard.isKingInKingCheck
  ChessBoard.isKingInKnightCheck
  ChessBoard.isKingInPawnCheck
  ChessBoard.isKingInStraightCheck
  ChessBoard.isKingLeftInCheck
  ChessBoard.isOnlyKingsLeft
  ChessBoard.isOpen
  ChessBoard.isValidBishopMove
  ChessBoard.isValidBishopMovement
  ChessBoard.isValidKingMove
  ChessBoard.isValidKingMovement
  ChessBoard.isValidKnightMove
  ChessBoard.isValidKnightMovement
  ChessBoard.isValidMove
  ChessBoard.isValidMoveColor
  ChessBoard.isValidMovement
  ChessBoard.isValidMovementPiece
  ChessBoard.isValidPawnAttack
  ChessBoard.isValidPawnMove
  ChessBoard.isValidPawnMovement
  ChessBoard.isValidPlayerMove
  ChessBoard.isValidQueenMove
  ChessBoard.isValidQueenMovement
  ChessBoard.isValidRookMove
  ChessBoard.isValidRookMovement
  ChessBoard.location
  ChessBoard.mkDiagLocs
  ChessBoard.movePiece
  ChessBoard.notColor
  ChessBoard.pawnRow
  ChessBoard.pieceValue
  ChessBoard.printBoard
  ChessBoard.printCol
  ChessBoard.printMaybePiece
  ChessBoard.printPiece
  ChessBoard.printPlayerScore
  ChessBoard.printRow
  ChessBoard.printScore
  ChessBoard.promotePawn
  ChessBoard.promotePawnBoard
  ChessBoard.removePiece
  ChessBoard.rowSep
  ChessBoard.startBoard
  ChessBoard.swapLoc
  ChessBoard.turnToColor
  ChessBoard.updateActive
  ChessBoard.updateBoard
  ChessBoard.updateCaptured
  ChessBoard.updateGameBoard
  ChessBoard.updateGamePlayers
  ChessBoard.updatePlayerName
  ChessBoard.updateScore
  ChessBoard.whitePlayer
  ChessBoard.Board
  ChessBoard.ChessPiece{ChessBoard.Bishop ChessBoard.King ChessBoard.Knight ChessBoard.Pawn ChessBoard.Queen ChessBoard.Rook}
  ChessBoard.ColLoc
  ChessBoard.Color{ChessBoard.Black ChessBoard.White}
  ChessBoard.Direction{ChessBoard.Backward ChessBoard.DiagBL ChessBoard.DiagBR ChessBoard.DiagFL ChessBoard.DiagFR ChessBoard.Forward ChessBoard.Leftt ChessBoard.Rightt}
  ChessBoard.Game{ChessBoard.Game gameBoard gamePlayer1 gamePlayer2}
  ChessBoard.GameOver{ChessBoard.CheckMate ChessBoard.StaleMate ChessBoard.Unfinished}
  ChessBoard.Location{ChessBoard.Location}
  ChessBoard.Piece{ChessBoard.Piece}
  ChessBoard.Pieces
  ChessBoard.Player{ChessBoard.Player active captured name playerColor score}
  ChessBoard.Row
  ChessBoard.RowLoc
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Foldable bdeac546b12282c8986759606b9295a5
import  -/  base-4.12.0.0:Data.Functor e667059569e58719cf8eee08191ebb1e
import  -/  base-4.12.0.0:Data.List 6c60559263db7cf0f22549b9673785b9
import  -/  base-4.12.0.0:Data.Maybe d07d5847f427040b05c592631bb0d4af
import  -/  base-4.12.0.0:Data.OldList 9c79c2259344fa5285ac49797d9c5db1
import  -/  base-4.12.0.0:Data.Tuple 3bf97d65c8e783335a95628f6e4f6f75
import  -/  base-4.12.0.0:GHC.Base fbe365a916ebeeeb4bc1f895dbe83e42
import  -/  base-4.12.0.0:GHC.List bb56c56a8dc21963b5824914872db158
import  -/  base-4.12.0.0:GHC.Num 8203d3fee487126cffd5e55ba5d0e8c3
import  -/  base-4.12.0.0:GHC.Show fa6032f3f820e8e8ec87b97bdca4e160
import  -/  base-4.12.0.0:Prelude 80c668cb99fbafebd524c5e897f8c982
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
51607fc8dbe32561da396ec7bbcc0615
  $fEqChessPiece :: GHC.Classes.Eq ChessBoard.ChessPiece
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.ChessPiece
                  ChessBoard.$fEqChessPiece_$c==
                  ChessBoard.$fEqChessPiece_$c/= -}
51607fc8dbe32561da396ec7bbcc0615
  $fEqChessPiece_$c/= ::
    ChessBoard.ChessPiece -> ChessBoard.ChessPiece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.ChessPiece) (y :: ChessBoard.ChessPiece) ->
                 case x2 of wild {
                   ChessBoard.Pawn
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Pawn -> GHC.Types.False }
                   ChessBoard.Bishop
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Bishop -> GHC.Types.False }
                   ChessBoard.Knight
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Knight -> GHC.Types.False }
                   ChessBoard.Rook
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Rook -> GHC.Types.False }
                   ChessBoard.Queen
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Queen -> GHC.Types.False }
                   ChessBoard.King
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.King -> GHC.Types.False } }) -}
51607fc8dbe32561da396ec7bbcc0615
  $fEqChessPiece_$c== ::
    ChessBoard.ChessPiece -> ChessBoard.ChessPiece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds1 :: ChessBoard.ChessPiece)
                   (ds2 :: ChessBoard.ChessPiece) ->
                 case ds1 of wild {
                   ChessBoard.Pawn
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Pawn -> GHC.Types.True }
                   ChessBoard.Bishop
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Bishop -> GHC.Types.True }
                   ChessBoard.Knight
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Knight -> GHC.Types.True }
                   ChessBoard.Rook
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Rook -> GHC.Types.True }
                   ChessBoard.Queen
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Queen -> GHC.Types.True }
                   ChessBoard.King
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.King -> GHC.Types.True } }) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fEqColor :: GHC.Classes.Eq ChessBoard.Color
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Color
                  ChessBoard.$fEqColor_$c==
                  ChessBoard.$fEqColor_$c/= -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fEqColor_$c/= ::
    ChessBoard.Color -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Color) (y :: ChessBoard.Color) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> case y of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> GHC.Types.True }
                   ChessBoard.White
                   -> case y of wild1 {
                        ChessBoard.Black -> GHC.Types.True
                        ChessBoard.White -> GHC.Types.False } }) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fEqColor_$c== ::
    ChessBoard.Color -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds1 :: ChessBoard.Color) (ds2 :: ChessBoard.Color) ->
                 case ds1 of wild {
                   ChessBoard.Black
                   -> case ds2 of wild1 {
                        ChessBoard.Black -> GHC.Types.True
                        ChessBoard.White -> GHC.Types.False }
                   ChessBoard.White
                   -> case ds2 of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> GHC.Types.True } }) -}
fb216e9851a09c8add07ec52ee0ffa4b
  $fEqDirection :: GHC.Classes.Eq ChessBoard.Direction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Direction
                  ChessBoard.$fEqDirection_$c==
                  ChessBoard.$fEqDirection_$c/= -}
fb216e9851a09c8add07ec52ee0ffa4b
  $fEqDirection_$c/= ::
    ChessBoard.Direction -> ChessBoard.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Direction) (y :: ChessBoard.Direction) ->
                 case x2 of wild {
                   ChessBoard.Forward
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Forward -> GHC.Types.False }
                   ChessBoard.Backward
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Backward -> GHC.Types.False }
                   ChessBoard.Leftt
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Leftt -> GHC.Types.False }
                   ChessBoard.Rightt
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.Rightt -> GHC.Types.False }
                   ChessBoard.DiagFR
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagFR -> GHC.Types.False }
                   ChessBoard.DiagBR
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagBR -> GHC.Types.False }
                   ChessBoard.DiagFL
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.DiagFL -> GHC.Types.False }
                   ChessBoard.DiagBL
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.DiagBL -> GHC.Types.False } }) -}
fb216e9851a09c8add07ec52ee0ffa4b
  $fEqDirection_$c== ::
    ChessBoard.Direction -> ChessBoard.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds1 :: ChessBoard.Direction)
                   (ds2 :: ChessBoard.Direction) ->
                 case ds1 of wild {
                   ChessBoard.Forward
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Forward -> GHC.Types.True }
                   ChessBoard.Backward
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Backward -> GHC.Types.True }
                   ChessBoard.Leftt
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Leftt -> GHC.Types.True }
                   ChessBoard.Rightt
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.Rightt -> GHC.Types.True }
                   ChessBoard.DiagFR
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagFR -> GHC.Types.True }
                   ChessBoard.DiagBR
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagBR -> GHC.Types.True }
                   ChessBoard.DiagFL
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.DiagFL -> GHC.Types.True }
                   ChessBoard.DiagBL
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.DiagBL -> GHC.Types.True } }) -}
866391a80495c905565168715eaeb98b
  $fEqGameOver :: GHC.Classes.Eq ChessBoard.GameOver
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.GameOver
                  ChessBoard.$fEqGameOver_$c==
                  ChessBoard.$fEqGameOver_$c/= -}
866391a80495c905565168715eaeb98b
  $fEqGameOver_$c/= ::
    ChessBoard.GameOver -> ChessBoard.GameOver -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.GameOver) (y :: ChessBoard.GameOver) ->
                 case x2 of wild {
                   ChessBoard.CheckMate
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.CheckMate -> GHC.Types.False }
                   ChessBoard.StaleMate
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True ChessBoard.StaleMate -> GHC.Types.False }
                   ChessBoard.Unfinished
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        ChessBoard.Unfinished -> GHC.Types.False } }) -}
866391a80495c905565168715eaeb98b
  $fEqGameOver_$c== ::
    ChessBoard.GameOver -> ChessBoard.GameOver -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds1 :: ChessBoard.GameOver) (ds2 :: ChessBoard.GameOver) ->
                 case ds1 of wild {
                   ChessBoard.CheckMate
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.CheckMate -> GHC.Types.True }
                   ChessBoard.StaleMate
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False ChessBoard.StaleMate -> GHC.Types.True }
                   ChessBoard.Unfinished
                   -> case ds2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        ChessBoard.Unfinished -> GHC.Types.True } }) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fEqPiece :: GHC.Classes.Eq ChessBoard.Piece
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Piece
                  ChessBoard.$fEqPiece_$c==
                  ChessBoard.$fEqPiece_$c/= -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fEqPiece_$c/= ::
    ChessBoard.Piece -> ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: ChessBoard.Piece) (y :: ChessBoard.Piece) ->
                 case ChessBoard.$fEqPiece_$c== x2 y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fEqPiece_$c== ::
    ChessBoard.Piece -> ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Piece) (w1 :: ChessBoard.Piece) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Piece ww4 ww5 ->
                 ChessBoard.$w$c== ww1 ww2 ww4 ww5 } }) -}
51607fc8dbe32561da396ec7bbcc0615
  $fShowChessPiece :: GHC.Show.Show ChessBoard.ChessPiece
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.ChessPiece
                  ChessBoard.$fShowChessPiece_$cshowsPrec
                  ChessBoard.$fShowChessPiece_$cshow
                  ChessBoard.$fShowChessPiece_$cshowList -}
25775eee31cbf189b2548e0acf0539e2
  $fShowChessPiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece2) -}
ca26d966ac494f4f48eea368bbdda0f4
  $fShowChessPiece10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("B"#) -}
b2a801cd64ecec4ba7938382f39d7f80
  $fShowChessPiece11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece12) -}
84a876f167b63c95f11edef5b284bae1
  $fShowChessPiece12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("P"#) -}
0f0fc5b5e985338e6ce4254a2c105b57
  $fShowChessPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("K"#) -}
34d29b2ca1e694e818fb0ebaecce5738
  $fShowChessPiece3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece4) -}
c2ae05b02b435369b3e3b49884be3e1d
  $fShowChessPiece4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Q"#) -}
2f21ef97bfda4e3aea3641a8361cc574
  $fShowChessPiece5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece6) -}
8610584ca36bf44cfa09ddc14b33837a
  $fShowChessPiece6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("R"#) -}
b01a0db313f1e0f85ce61ebc38965dd9
  $fShowChessPiece7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece8) -}
dbe0392c77d072fb1674b8d722dd2884
  $fShowChessPiece8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("N"#) -}
9e9193ab9364ed59866a8c1ccfcad930
  $fShowChessPiece9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowChessPiece10) -}
51607fc8dbe32561da396ec7bbcc0615
  $fShowChessPiece_$cshow :: ChessBoard.ChessPiece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.ChessPiece) ->
                 case ds1 of wild {
                   ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                   ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                   ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                   ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                   ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                   ChessBoard.King -> ChessBoard.$fShowChessPiece1 }) -}
51607fc8dbe32561da396ec7bbcc0615
  $fShowChessPiece_$cshowList ::
    [ChessBoard.ChessPiece] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.ChessPiece]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.ChessPiece
                   ChessBoard.$w$cshowsPrec
                   ls
                   s) -}
51607fc8dbe32561da396ec7bbcc0615
  $fShowChessPiece_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.ChessPiece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.ChessPiece)
                   (w2 :: GHC.Base.String) ->
                 ChessBoard.$w$cshowsPrec w1 w2) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fShowColor :: GHC.Show.Show ChessBoard.Color
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Color
                  ChessBoard.$fShowColor_$cshowsPrec
                  ChessBoard.$fShowColor_$cshow
                  ChessBoard.$fShowColor_$cshowList -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fShowColor1 :: ChessBoard.Color -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: ChessBoard.Color) (s :: GHC.Base.String) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n8 :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n8
                           ChessBoard.$fShowChessPiece9)
                        s
                   ChessBoard.White
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n8 :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n8 ChessBoard.$fShowColor2)
                        s }) -}
301c7f69f37a39fd99bfafca450f0230
  $fShowColor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowColor3) -}
f97401eb4a27b45ed9c67d6b048b26eb
  $fShowColor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("W"#) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fShowColor_$cshow :: ChessBoard.Color -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Color) ->
                 case ds1 of wild {
                   ChessBoard.Black -> ChessBoard.$fShowChessPiece9
                   ChessBoard.White -> ChessBoard.$fShowColor2 }) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fShowColor_$cshowList :: [ChessBoard.Color] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Color]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Color
                   ChessBoard.$fShowColor1
                   ls
                   s) -}
8c02f1645e49ff56e8ac2e9604a2be0b
  $fShowColor_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Color -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds1 :: GHC.Types.Int)
                   (x2 :: ChessBoard.Color)
                   (s :: GHC.Base.String) ->
                 case x2 of wild {
                   ChessBoard.Black
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n8 :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c
                           n8
                           ChessBoard.$fShowChessPiece9)
                        s
                   ChessBoard.White
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n8 :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n8 ChessBoard.$fShowColor2)
                        s }) -}
866391a80495c905565168715eaeb98b
  $fShowGameOver :: GHC.Show.Show ChessBoard.GameOver
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.GameOver
                  ChessBoard.$fShowGameOver_$cshowsPrec
                  ChessBoard.$fShowGameOver_$cshow
                  ChessBoard.$fShowGameOver_$cshowList -}
4fd007f9dbb6a222b1a48713621846b8
  $fShowGameOver1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver2) -}
c010e5ed36ae8e1f8c58667f6c0115bf
  $fShowGameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Unfinished"#) -}
a4e692bd1cced4b7e22efb03494db34b
  $fShowGameOver3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver4) -}
25a01c9d6bb5c276f5df4cefdc7503c4
  $fShowGameOver4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StaleMate"#) -}
b6816a2cdc38cb195226a0e229c0fc0c
  $fShowGameOver5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowGameOver6) -}
ba85df85c53d3bc33f44b605fe093bbe
  $fShowGameOver6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("CheckMate"#) -}
866391a80495c905565168715eaeb98b
  $fShowGameOver_$cshow :: ChessBoard.GameOver -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: ChessBoard.GameOver) ->
                 case x2 of wild {
                   ChessBoard.CheckMate -> ChessBoard.$fShowGameOver5
                   ChessBoard.StaleMate -> ChessBoard.$fShowGameOver3
                   ChessBoard.Unfinished -> ChessBoard.$fShowGameOver1 }) -}
866391a80495c905565168715eaeb98b
  $fShowGameOver_$cshowList ::
    [ChessBoard.GameOver] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.GameOver]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.GameOver
                   ChessBoard.$w$cshowsPrec1
                   ls
                   s) -}
866391a80495c905565168715eaeb98b
  $fShowGameOver_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.GameOver -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.GameOver)
                   (w2 :: GHC.Base.String) ->
                 ChessBoard.$w$cshowsPrec1 w1 w2) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation :: GHC.Show.Show ChessBoard.Location
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Location
                  ChessBoard.$fShowLocation_$cshowsPrec
                  ChessBoard.$fShowLocation_$cshow
                  ChessBoard.$fShowLocation_$cshowList -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation1 :: ChessBoard.Location -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U(U))><L,1*U>,
     Unfolding: (\ (w :: ChessBoard.Location) (w1 :: GHC.Base.String) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshowsPrec2 ww4 ww2 w1 } }) -}
a5f4a087ffe014a19991b83911e29fe8
  $fShowLocation10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation11) -}
e05337ad7fb843a0080cc9efe160a655
  $fShowLocation11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("D"#) -}
60b214e68244e6336d47689a99a04883
  $fShowLocation12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation13) -}
3ae6652c59a7d7f5ac97e12cedcd9700
  $fShowLocation13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("C"#) -}
37c51fcf6954abcf5660036a7abb8f99
  $fShowLocation14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation15) -}
bf1bee403446e6d736104ffac9686ed7
  $fShowLocation15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("A"#) -}
890f7f82e809ba9ff6b333ee11bd0bcc
  $fShowLocation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation17) -}
3821607b7609ee6621cb077cb538ecd5
  $fShowLocation17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Error"#) -}
fe1d2f2b173eb4c3166252eaf1f410ac
  $fShowLocation2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation3) -}
3718dd72a97cc974b195d31366fe643c
  $fShowLocation3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("H"#) -}
93bab02e4980e4f1f25313021fbde7c2
  $fShowLocation4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation5) -}
e43dd2f3232bc4ae097db783f752e30d
  $fShowLocation5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("G"#) -}
f41caea969b04014971bc066a64d4dd5
  $fShowLocation6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation7) -}
52394a462cbd20b22264f8197fdd3743
  $fShowLocation7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("F"#) -}
0f0f4c0bde349211d39a2079b0db613b
  $fShowLocation8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.$fShowLocation9) -}
75876a2ac7ec0e9dcb403e8dd732f622
  $fShowLocation9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("E"#) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshow :: ChessBoard.Location -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshow ww4 ww2 } }) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshowList ::
    [ChessBoard.Location] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Location]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Location
                   ChessBoard.$fShowLocation1
                   ls
                   s) -}
61763d609e56610dc321c7932fa09a95
  $fShowLocation_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Location -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,A><S(S(S)L),1*U(1*U(1*U),1*U(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.Location)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 ChessBoard.$w$cshowsPrec2 ww4 ww2 w2 } }) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fShowPiece :: GHC.Show.Show ChessBoard.Piece
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Piece
                  ChessBoard.$fShowPiece_$cshowsPrec
                  ChessBoard.$fShowPiece_$cshow
                  ChessBoard.$fShowPiece_$cshowList -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fShowPiece1 ::
    ChessBoard.Piece -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SL),1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: ChessBoard.Piece) (s :: GHC.Base.String)[OneShot] ->
                 case x2 of wild { ChessBoard.Piece c cp ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n8 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c1
                      n8
                      (ChessBoard.printPiece c cp))
                   s }) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fShowPiece_$cshow :: ChessBoard.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Piece) ->
                 case ds1 of wild { ChessBoard.Piece c cp ->
                 ChessBoard.printPiece c cp }) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fShowPiece_$cshowList :: [ChessBoard.Piece] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Piece]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Piece
                   ChessBoard.$fShowPiece1
                   ls
                   s) -}
1911fdf70f07e10faf3d52dd1b71ed25
  $fShowPiece_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Piece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SL),1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds1 :: GHC.Types.Int)
                   (x2 :: ChessBoard.Piece)
                   (s :: GHC.Base.String) ->
                 case x2 of wild { ChessBoard.Piece c cp ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n8 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c1
                      n8
                      (ChessBoard.printPiece c cp))
                   s }) -}
0c8660847805700d74fd94c21ab37e42
  $fShowPlayer :: GHC.Show.Show ChessBoard.Player
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ChessBoard.Player
                  ChessBoard.$fShowPlayer_$cshowsPrec
                  ChessBoard.$fShowPlayer_$cshow
                  ChessBoard.$fShowPlayer_$cshowList -}
0c8660847805700d74fd94c21ab37e42
  $fShowPlayer1 :: ChessBoard.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U(U))><L,U>,
     Unfolding: (\ (w :: ChessBoard.Player) (w1 :: GHC.Base.String) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 ChessBoard.$w$cshowsPrec3 0# ww1 ww2 ww3 ww4 ww5 w1 }) -}
ebfc72f61778ace27caa99d0c2fa9c95
  $fShowPlayer2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
0c8660847805700d74fd94c21ab37e42
  $fShowPlayer_$cshow :: ChessBoard.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: ChessBoard.Player) ->
                 ChessBoard.$fShowPlayer_$cshowsPrec
                   ChessBoard.$fShowPlayer2
                   x2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0c8660847805700d74fd94c21ab37e42
  $fShowPlayer_$cshowList :: [ChessBoard.Player] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [ChessBoard.Player]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ChessBoard.Player
                   ChessBoard.$fShowPlayer1
                   ls
                   s) -}
0c8660847805700d74fd94c21ab37e42
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> ChessBoard.Player -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: ChessBoard.Player)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { ChessBoard.Player ww3 ww4 ww5 ww6 ww7 ->
                 ChessBoard.$w$cshowsPrec3 ww1 ww3 ww4 ww5 ww6 ww7 w2 } }) -}
6bbd0b1da256987b5c374ff1b28945be
  $tc'Backward :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3701717171427713210##
                   17837981855696506380##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Backward2
                   0#
                   ChessBoard.$tc'Backward1) -}
e98de1a6e1eeacd40a75f6d944575d95
  $tc'Backward1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
f1a5080ad09e1b546d09934d84896da4
  $tc'Backward2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Backward3) -}
0c603284576d27918016bc058b11e9c2
  $tc'Backward3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Backward"#) -}
f76ba18e19d0ea9d320ddf7137d61c3d
  $tc'Bishop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1859922600471315242##
                   9392862694933984042##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Bishop2
                   0#
                   ChessBoard.$tc'Bishop1) -}
8618b76cc4c5d06a52c67a374aba383c
  $tc'Bishop1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
b74d0a863ffb347c7c12e53881e029b0
  $tc'Bishop2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Bishop3) -}
f3f6bc3c781f667e98a2cfdb6fd73557
  $tc'Bishop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bishop"#) -}
00a647521c62022834ed1673528df508
  $tc'Black :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17360399565767765397##
                   10956204482306786931##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Black2
                   0#
                   ChessBoard.$tc'Black1) -}
02f82bda94a780954775af5aa83f96f9
  $tc'Black1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
effc5bca8673faf71501b9db6375ecbf
  $tc'Black2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Black3) -}
44348573747af1a772959c5c880a9aad
  $tc'Black3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Black"#) -}
f72dcde621eecbfff900986c11643939
  $tc'CheckMate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   244229523097746280##
                   6713682609734780876##
                   ChessBoard.$trModule
                   ChessBoard.$tc'CheckMate2
                   0#
                   ChessBoard.$tc'CheckMate1) -}
9bd4a178aa80c2744e1c58bdd00584ec
  $tc'CheckMate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
b706b236ccb5f72e9ef8831df20d0530
  $tc'CheckMate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'CheckMate3) -}
16ab9fc0ba091fadb60f11e67ec7d5bf
  $tc'CheckMate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CheckMate"#) -}
d26f7a8337a0cf375f6f837a3c666923
  $tc'DiagBL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6376024874887997916##
                   6618291504245642917##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagBL1
                   0#
                   ChessBoard.$tc'Backward1) -}
626e394a07db5c34da0ba2216e8ecef8
  $tc'DiagBL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagBL2) -}
b490bf3e12a305605d3e24c323e2a12c
  $tc'DiagBL2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagBL"#) -}
4319638970d2bce6a52c001c49e1e4c9
  $tc'DiagBR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10314828229921814719##
                   8189800409704871031##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagBR1
                   0#
                   ChessBoard.$tc'Backward1) -}
e26f6bff9fae7f79146ae08a9933ebed
  $tc'DiagBR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagBR2) -}
62633b0da65acd0f23b5aec3621c55e3
  $tc'DiagBR2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagBR"#) -}
3b394f101e9952ed2512ef1957ac4359
  $tc'DiagFL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14156882257518125914##
                   5128305356499999878##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagFL1
                   0#
                   ChessBoard.$tc'Backward1) -}
d5c9c08be0cb9544ad6c2d0c7fdf931f
  $tc'DiagFL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagFL2) -}
33ed516122811b7a8298773d38e0c6c5
  $tc'DiagFL2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagFL"#) -}
03b69a2c1f8a83fadb2dbd5aaefc2e2a
  $tc'DiagFR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18363776098993942452##
                   5773539533621295392##
                   ChessBoard.$trModule
                   ChessBoard.$tc'DiagFR1
                   0#
                   ChessBoard.$tc'Backward1) -}
f2326ac2016f8dd92f15bf204092ec66
  $tc'DiagFR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'DiagFR2) -}
541b9dd7979b806d98e473c85d151e07
  $tc'DiagFR2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DiagFR"#) -}
2762b5fc69b5a946aa3edcc8039d2288
  $tc'Forward :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14249913380963119407##
                   11123840718080238294##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Forward1
                   0#
                   ChessBoard.$tc'Backward1) -}
4cfdeb00508ad1390cd2161b036cf483
  $tc'Forward1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Forward2) -}
03a7674c798c5ccdf08f1c4078072729
  $tc'Forward2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Forward"#) -}
d61287b576e030d21f03088394eb13b3
  $tc'Game :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17864205669972082914##
                   16982876703268251754##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Game2
                   0#
                   ChessBoard.$tc'Game1) -}
e73763d724abae745e8125dc7ddd75a4
  $tc'Game1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
deec658d22298d1031af4fe23f7a7ec3
  $tc'Game2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Game3) -}
9e6d8b21fbb11fe9341e8880554510bb
  $tc'Game3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Game"#) -}
3e4f3a705d2092217fcf6a13fad1cf2d
  $tc'King :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14212754542616103717##
                   7554362502951841670##
                   ChessBoard.$trModule
                   ChessBoard.$tc'King1
                   0#
                   ChessBoard.$tc'Bishop1) -}
90785b9edd6fb11875c5c69a9cc5ee6c
  $tc'King1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'King2) -}
46b1065b1f802e8a9e0eb4aa3cdf94ef
  $tc'King2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'King"#) -}
4aa219b688665a4bb3a8f1004a229d00
  $tc'Knight :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15217035523706160804##
                   3502406585153355550##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Knight1
                   0#
                   ChessBoard.$tc'Bishop1) -}
5caf2180c99ec4e23ed08d6e4232d230
  $tc'Knight1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Knight2) -}
ea20503bb07c289ca0b113915acca7d4
  $tc'Knight2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Knight"#) -}
5387b89f7b07e94614d721735d5a4741
  $tc'Leftt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7493666668227912972##
                   12540698331853241459##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Leftt1
                   0#
                   ChessBoard.$tc'Backward1) -}
9922ed2e830fd5aa303fc8f516410a47
  $tc'Leftt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Leftt2) -}
f07425f940265e19df12f9b01220abef
  $tc'Leftt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leftt"#) -}
40aa7374febe7013549054d073408a1e
  $tc'Location :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9062991653214768393##
                   7337080452892193561##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Location2
                   0#
                   ChessBoard.$tc'Location1) -}
6329b51a8c686d372b474dcebc1c88b5
  $tc'Location1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
31c519aef26b44200a8d029960821d58
  $tc'Location2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Location3) -}
2f04a37a7fe3212a56203e71a1733c4d
  $tc'Location3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Location"#) -}
585374a118b23666494f910a3ee79e98
  $tc'Pawn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6334934572900286720##
                   10133371348699454777##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Pawn1
                   0#
                   ChessBoard.$tc'Bishop1) -}
b3f856d45e9b4f6d13d8586b2225bff5
  $tc'Pawn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Pawn2) -}
82c67bc720d79e2d06db73fd11b45a6c
  $tc'Pawn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pawn"#) -}
0c6f7b08897956a4e46df42a97113d6f
  $tc'Piece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7755712274710907797##
                   14249138036874745735##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Piece2
                   0#
                   ChessBoard.$tc'Piece1) -}
14c3c7d38c2b97aff6e7e434fc037dad
  $tc'Piece1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4f6df4c0e1de5cf2c9f4a9b437350f6e
  $tc'Piece2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Piece3) -}
0c6ca6eaba050c452fa1c89c593b7b89
  $tc'Piece3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Piece"#) -}
b2fe241d1e0f097c2eb7a04306320bc6
  $tc'Player :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5983525802846579206##
                   18334041469456993763##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Player2
                   0#
                   ChessBoard.$tc'Player1) -}
c0a45672a95ecd2b7cf774056e0d52ab
  $tc'Player1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9cb816f527ad254495ad3a889df74b4d
  $tc'Player2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Player3) -}
37723fc3291647f711fe5af93bd70e29
  $tc'Player3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Player"#) -}
702b5ba2b18593cdeae0bc14ff724bde
  $tc'Queen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10427081638620225486##
                   11982980599722597220##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Queen1
                   0#
                   ChessBoard.$tc'Bishop1) -}
022d504e72858eb1dc6bc33d8d5f74e5
  $tc'Queen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Queen2) -}
00d3073bf1b18df5aa5bc8145eac59b0
  $tc'Queen2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Queen"#) -}
db1343954e4fb141be0120adc34c840d
  $tc'Rightt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17726700910068818784##
                   7541693408495280534##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Rightt1
                   0#
                   ChessBoard.$tc'Backward1) -}
e4db1d766aca27dc32c9e6d9201d2e00
  $tc'Rightt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Rightt2) -}
2601912ec1bcbb6ea7f4da515e5c3b39
  $tc'Rightt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rightt"#) -}
4361cd45d19efcf5b8cf269d410e395b
  $tc'Rook :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2765951124866374374##
                   429280785758157496##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Rook1
                   0#
                   ChessBoard.$tc'Bishop1) -}
8ede3ffae7d71738e4a7d4572c7b561f
  $tc'Rook1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Rook2) -}
1c4dcd3bedcbabcb9e1b7b8082117ffe
  $tc'Rook2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rook"#) -}
2ad4d1223b2d1c2d315eb15f4d11ea39
  $tc'StaleMate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4918757790118876704##
                   481521187216262725##
                   ChessBoard.$trModule
                   ChessBoard.$tc'StaleMate1
                   0#
                   ChessBoard.$tc'CheckMate1) -}
2f0b56e27cf527f2dc28fc24a4c4175e
  $tc'StaleMate1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'StaleMate2) -}
9886a647b903cc8e65420006b7db52a3
  $tc'StaleMate2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StaleMate"#) -}
6a5a83bbe06e20ef1544b796c9f02e6f
  $tc'Unfinished :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9828605474628407994##
                   292116914215697706##
                   ChessBoard.$trModule
                   ChessBoard.$tc'Unfinished1
                   0#
                   ChessBoard.$tc'CheckMate1) -}
bdb2db90bcf600f2dd80ea58464f94a8
  $tc'Unfinished1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'Unfinished2) -}
36fcbaefd95974ba1fc4eb4a6081559a
  $tc'Unfinished2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unfinished"#) -}
a9a85a4f5e8722e2e7a032a8c4dac513
  $tc'White :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7473999497024262200##
                   10331176697546301907##
                   ChessBoard.$trModule
                   ChessBoard.$tc'White1
                   0#
                   ChessBoard.$tc'Black1) -}
9caba357de3e681c8cc46b7a073f1cad
  $tc'White1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tc'White2) -}
8fa322a5cac174e1c44d3b48930e8581
  $tc'White2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'White"#) -}
e8952c1929180d36bcab8b320e098e7d
  $tcChessPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7777171357180282469##
                   13597314580726789729##
                   ChessBoard.$trModule
                   ChessBoard.$tcChessPiece1
                   0#
                   GHC.Types.krep$*) -}
c46fb4c8bc6f3ec9cd5638495a42e9ff
  $tcChessPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcChessPiece2) -}
ba5b03863baa28d758afe2a3f888e54e
  $tcChessPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChessPiece"#) -}
e5f766bb5ceb8214299e4e4c782fa684
  $tcColor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2967709801297043498##
                   16171954743078143482##
                   ChessBoard.$trModule
                   ChessBoard.$tcColor1
                   0#
                   GHC.Types.krep$*) -}
9e7443ac618592cf54b1d015ddf2a7aa
  $tcColor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcColor2) -}
da125fe09bac6416b592e2e856f6e3e8
  $tcColor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Color"#) -}
018a6f5394a5653a7a644b36dd94c425
  $tcDirection :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15838310744117077221##
                   8057800576995639210##
                   ChessBoard.$trModule
                   ChessBoard.$tcDirection1
                   0#
                   GHC.Types.krep$*) -}
76a1301a562d8a79a9574ce166075aeb
  $tcDirection1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcDirection2) -}
31f6022eb4d13f3b68548b3d39d728eb
  $tcDirection2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Direction"#) -}
428a8a7716fa3a9b118f51a241efb43e
  $tcGame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3132135774796161636##
                   9322976130798821795##
                   ChessBoard.$trModule
                   ChessBoard.$tcGame1
                   0#
                   GHC.Types.krep$*) -}
a882cf40a198865bc49b3ddec238ed30
  $tcGame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcGame2) -}
2c5debd32faa97b7c0659df75d3808ad
  $tcGame2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Game"#) -}
d5e56e84d9101b03ebc5ab5f1eb24c12
  $tcGameOver :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18176669151516859591##
                   1818438445336014487##
                   ChessBoard.$trModule
                   ChessBoard.$tcGameOver1
                   0#
                   GHC.Types.krep$*) -}
9beeabf524386bd003c28e3852351978
  $tcGameOver1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcGameOver2) -}
0e4286ddd800378edf825171398aa802
  $tcGameOver2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GameOver"#) -}
45d2282971ceff46e258d067eb3c9786
  $tcLocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9003094257349354805##
                   7506062213225909215##
                   ChessBoard.$trModule
                   ChessBoard.$tcLocation1
                   0#
                   GHC.Types.krep$*) -}
08cf8521325c1efbac3ce2850c164de4
  $tcLocation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcLocation2) -}
7b6655aa7ad77b01b08d2c7c59d4af30
  $tcLocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Location"#) -}
726abc874b58293b5cefbec328ce829b
  $tcPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   148386750547179083##
                   17058407329145243634##
                   ChessBoard.$trModule
                   ChessBoard.$tcPiece1
                   0#
                   GHC.Types.krep$*) -}
a5bdbba1d08819b7d46651b3b8255b91
  $tcPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcPiece2) -}
a8a8ce4c1632f694e29628d01d153b55
  $tcPiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Piece"#) -}
c65346cb0c9746f03c4e93cb2358fd93
  $tcPlayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9042444837851077251##
                   17916954981088333718##
                   ChessBoard.$trModule
                   ChessBoard.$tcPlayer1
                   0#
                   GHC.Types.krep$*) -}
b01f40850e958242ef99c9bc2ac78c09
  $tcPlayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$tcPlayer2) -}
1f9eee05ec4b0401a8858d1402a6f331
  $tcPlayer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player"#) -}
3610b7d4d46a9056b8cfd1e9684cf721
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ChessBoard.$trModule3
                   ChessBoard.$trModule1) -}
a3f731f006517cefce0b05ecbb7a6084
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$trModule2) -}
5a879a63aef343911723d9e2921ada42
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChessBoard"#) -}
c9293ec950687ba9eab5a696cf3a7007
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ChessBoard.$trModule4) -}
bf40c7b384d489d57ba48e7662a754a2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
f416be842945cca718bebe1c02c01d9b
  $w$c== ::
    ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Color)
                   (ww1 :: ChessBoard.ChessPiece)
                   (ww2 :: ChessBoard.Color)
                   (ww3 :: ChessBoard.ChessPiece) ->
                 case ww of wild {
                   ChessBoard.Black
                   -> case ww2 of wild1 {
                        ChessBoard.Black -> ChessBoard.$fEqChessPiece_$c== ww1 ww3
                        ChessBoard.White -> GHC.Types.False }
                   ChessBoard.White
                   -> case ww2 of wild1 {
                        ChessBoard.Black -> GHC.Types.False
                        ChessBoard.White -> ChessBoard.$fEqChessPiece_$c== ww1 ww3 } }) -}
5205fb34987bffa3a09968daac1282e8
  $w$cshow :: GHC.Prim.Int# -> ChessBoard.RowLoc -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: ChessBoard.RowLoc) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintCol ww)
                   (case ww1 of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
51607fc8dbe32561da396ec7bbcc0615
  $w$cshowsPrec ::
    ChessBoard.ChessPiece -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.ChessPiece)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   ChessBoard.Pawn
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece11 w1
                   ChessBoard.Bishop
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece9 w1
                   ChessBoard.Knight
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece7 w1
                   ChessBoard.Rook
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece5 w1
                   ChessBoard.Queen
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece3 w1
                   ChessBoard.King
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowChessPiece1
                        w1 }) -}
866391a80495c905565168715eaeb98b
  $w$cshowsPrec1 ::
    ChessBoard.GameOver -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.GameOver) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   ChessBoard.CheckMate
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver5 w1
                   ChessBoard.StaleMate
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver3 w1
                   ChessBoard.Unfinished
                   -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowGameOver1 w1 }) -}
e5987e4d79a55bc89f789668aac5378c
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> ChessBoard.RowLoc -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,1*U(U)><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (w :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintCol ww)
                   (case ww1 of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++_$s++ @ GHC.Types.Char w ww5 ww6 } })) -}
617b82a88205e7f12efb05d98b10902d
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> ChessBoard.Color
    -> ChessBoard.Pieces
    -> ChessBoard.Pieces
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [2] -}
6bf438a56557ad7b311c452ebcb61171
  $wchangeBoard ::
    ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> [[GHC.Maybe.Maybe ChessBoard.Piece]]
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(U)><S,U>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (w1 :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w2 :: ChessBoard.ColLoc)
                   (ww :: GHC.Prim.Int#) ->
                 let {
                   $j :: [ChessBoard.Row]
                         -> [ChessBoard.Row] -> [[GHC.Maybe.Maybe ChessBoard.Piece]]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (x2 :: [ChessBoard.Row])[OneShot]
                       (ds1 :: [ChessBoard.Row])[OneShot] ->
                     GHC.Base.++
                       @ [GHC.Maybe.Maybe ChessBoard.Piece]
                       x2
                       (GHC.Types.:
                          @ [GHC.Maybe.Maybe ChessBoard.Piece]
                          (case w2 of wild { GHC.Types.I# x3 ->
                           case GHC.Prim.<=# x3 0# of lwild {
                             DEFAULT
                             -> case ds1 of wild1 {
                                  []
                                  -> case GHC.List.badHead
                                     ret_ty [GHC.Maybe.Maybe ChessBoard.Piece]
                                     of {}
                                  : x4 ds2
                                  -> case x4 of wild2 {
                                       []
                                       -> GHC.Base.++
                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                            (GHC.Types.[] @ (GHC.Maybe.Maybe ChessBoard.Piece))
                                            (GHC.Types.:
                                               @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                               w1
                                               (GHC.List.scanl2
                                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)))
                                       : ipv ipv1
                                       -> case x3 of ds3 {
                                            DEFAULT
                                            -> let {
                                                 ds4 :: ([GHC.Maybe.Maybe ChessBoard.Piece],
                                                         [GHC.Maybe.Maybe ChessBoard.Piece])
                                                 = case GHC.List.splitAt_$s$wsplitAt'
                                                          @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                          ipv1
                                                          (GHC.Prim.-#
                                                             ds3
                                                             1#) of ww1 { (#,#) ww2 ww3 ->
                                                   (ww2, ww3) }
                                               } in
                                               GHC.Base.++_$s++
                                                 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                 (GHC.Types.:
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                    w1
                                                    (case ds4 of wild3 { (,) xs' xs'' ->
                                                     case xs'' of wild4 {
                                                       []
                                                       -> GHC.List.scanl2
                                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                       : ds5 xs -> xs } }))
                                                 ipv
                                                 (case ds4 of wild3 { (,) xs' xs'' -> xs' })
                                            1#
                                            -> GHC.Base.++_$s++
                                                 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                 (GHC.Types.:
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                    w1
                                                    (case ipv1 of wild3 {
                                                       []
                                                       -> GHC.List.scanl2
                                                            @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                       : ds4 xs -> xs }))
                                                 ipv
                                                 (GHC.Types.[]
                                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)) } } }
                             1#
                             -> GHC.Base.++
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.Types.[] @ (GHC.Maybe.Maybe ChessBoard.Piece))
                                  (GHC.Types.:
                                     @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                     w1
                                     (case ds1 of wild1 {
                                        []
                                        -> case GHC.List.badHead
                                           ret_ty [GHC.Maybe.Maybe ChessBoard.Piece]
                                           of {}
                                        : x4 ds2
                                        -> case x4 of wild2 {
                                             []
                                             -> GHC.List.scanl2 @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                             : ds3 xs -> xs } })) } })
                          (case ds1 of wild {
                             [] -> GHC.List.scanl2 @ ChessBoard.Row : ds2 xs -> xs }))
                 } in
                 case GHC.Prim.<=# ww 0# of lwild {
                   DEFAULT
                   -> case w of wild {
                        []
                        -> $j
                             (GHC.Types.[] @ ChessBoard.Row)
                             (GHC.Types.[] @ ChessBoard.Row)
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([ChessBoard.Row], [ChessBoard.Row])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ ChessBoard.Row
                                           ipv1
                                           (GHC.Prim.-# ds1 1#) of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                $j
                                  (GHC.Types.:
                                     @ ChessBoard.Row
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (case ds2 of wild2 { (,) xs' xs'' -> xs'' })
                             1#
                             -> $j
                                  (GHC.Types.: @ ChessBoard.Row ipv (GHC.Types.[] @ ChessBoard.Row))
                                  ipv1 } }
                   1# -> $j (GHC.Types.[] @ ChessBoard.Row) w }) -}
6c7d92c6abf1d8aa1bbf49ae0a22d36f
  $wcheckPawnPromotion ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U><S,U><S,U><L,1*U(1*U)>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: ChessBoard.RowLoc) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row ww ww2)
                        ww1 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just a1
                   -> case a1 of wild1 { ChessBoard.Piece ds1 cp ->
                      case cp of wild2 {
                        ChessBoard.Pawn
                        -> case ww3 of wild3 { GHC.Types.I# x2 ->
                           case x2 of wild4 {
                             DEFAULT -> GHC.Types.False
                             0# -> GHC.Types.True
                             7# -> GHC.Types.True } }
                        ChessBoard.Bishop -> GHC.Types.False
                        ChessBoard.Knight -> GHC.Types.False
                        ChessBoard.Rook -> GHC.Types.False
                        ChessBoard.Queen -> GHC.Types.False
                        ChessBoard.King -> GHC.Types.False } } }) -}
94cb8a1465157aaed52ff1b6a4a500da
  $wcheckPiece ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 3, Strictness: <L,1*U><S,U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: ChessBoard.RowLoc) ->
                 case GHC.Prim.># ww 7# of lwild {
                   DEFAULT
                   -> case GHC.Prim.<# ww 0# of lwild1 {
                        DEFAULT
                        -> case w1 of wild { GHC.Types.I# x2 ->
                           case GHC.Prim.># x2 7# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.<# x2 0# of lwild3 {
                                  DEFAULT
                                  -> GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w x2)
                                       ww
                                  1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }
                             1# -> GHC.Maybe.Nothing @ ChessBoard.Piece } }
                        1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }
                   1# -> GHC.Maybe.Nothing @ ChessBoard.Piece }) -}
42ddcb5a746eff4ab9136412f251bc2a
  $wcycleBoardCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U,A,A)><L,U><L,1*U(1*U)><S,1*U>,
     Inline: [2] -}
1293a7843e36211cf08225bd6f04aa1f
  $wcycleMoveCheck ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,U><L,U><S,U><S,U>, Inline: [2] -}
3090a52733e5bfe40bc80cf78b5e11b0
  $wfirstPiece ::
    ChessBoard.Direction
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 4, Strictness: <L,U><S,U><L,1*U(U)><L,U>, Inline: [2] -}
1478b42f0f6d2da8f6e33913e4dbb9a2
  $wgetKingInBoard ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 4, Strictness: <S,U><L,U><S,1*U><S,U>, Inline: [2] -}
fcabad66843ffcbc3a00c68250a63f1c
  $wisAnyBishopMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 let {
                   col :: ChessBoard.ColLoc = GHC.Types.I# ww
                 } in
                 case ChessBoard.$wisAnyMoveRecurse
                        w
                        w1
                        col
                        w2
                        (GHC.Prim.+# ww 1#)
                        (case w2 of wild { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.+# x2 1#) })
                        ChessBoard.DiagFR of wild {
                   GHC.Types.False
                   -> case ChessBoard.$wisAnyMoveRecurse
                             w
                             w1
                             col
                             w2
                             (GHC.Prim.-# ww 1#)
                             (case w2 of wild1 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.+# x2 1#) })
                             ChessBoard.DiagFL of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.+# ww 1#)
                                  (case w2 of wild2 { GHC.Types.I# x2 ->
                                   GHC.Types.I# (GHC.Prim.-# x2 1#) })
                                  ChessBoard.DiagBR of wild2 {
                             GHC.Types.False
                             -> ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.-# ww 1#)
                                  (case w2 of wild3 { GHC.Types.I# x2 ->
                                   GHC.Types.I# (GHC.Prim.-# x2 1#) })
                                  ChessBoard.DiagBL
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
e70ee7484c86b12fb6671cd23fb5596f
  $wisAnyKingMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
b67448182e94251cba3881b62dd88928
  $wisAnyKnightMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
6ed0c42f4ceb569d99cb99c53cebb462
  $wisAnyMoveRecurse ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Direction
    -> GHC.Types.Bool
  {- Arity: 7,
     Strictness: <L,1*U(U,A,A)><L,U><L,1*U(U)><L,U(U)><S,U><L,1*U(U)><L,U>,
     Inline: [2] -}
11feea234dc6e9c375f27b820176e48f
  $wisAnyPawnMove ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,U><S,U><L,U(U)>, Inline: [2] -}
06a05ddcbb6262c1bb3dfe626d33bf96
  $wisAnyQueenMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 case ChessBoard.$wisAnyBishopMove w w1 ww w2 of wild {
                   GHC.Types.False -> ChessBoard.$wisAnyRookMove w w1 ww w2
                   GHC.Types.True -> GHC.Types.True }) -}
414cbf15d31448c4690c04f0089512db
  $wisAnyRookMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: ChessBoard.RowLoc) ->
                 let {
                   col :: ChessBoard.ColLoc = GHC.Types.I# ww
                 } in
                 case ChessBoard.$wisAnyMoveRecurse
                        w
                        w1
                        col
                        w2
                        ww
                        (case w2 of wild { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.+# x2 1#) })
                        ChessBoard.Forward of wild {
                   GHC.Types.False
                   -> case ChessBoard.$wisAnyMoveRecurse
                             w
                             w1
                             col
                             w2
                             ww
                             (case w2 of wild1 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.-# x2 1#) })
                             ChessBoard.Backward of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.-# ww 1#)
                                  w2
                                  ChessBoard.Leftt of wild2 {
                             GHC.Types.False
                             -> ChessBoard.$wisAnyMoveRecurse
                                  w
                                  w1
                                  col
                                  w2
                                  (GHC.Prim.+# ww 1#)
                                  w2
                                  ChessBoard.Rightt
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
c68b2fa72e4931172cde48d46b898fae
  $wisClearPath ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><L,U>, Inline: [2] -}
0e796eb47fcb9300a606f7e74eada5b6
  $wisGameOver ::
    ChessBoard.Board
    -> ChessBoard.Pieces
    -> ChessBoard.Pieces
    -> ChessBoard.Color
    -> ChessBoard.GameOver
  {- Arity: 4, Strictness: <L,U><S,1*U><L,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board)
                   (ww1 :: ChessBoard.Pieces)
                   (ww2 :: ChessBoard.Pieces)
                   (w :: ChessBoard.Color) ->
                 let {
                   $j :: ChessBoard.GameOver <join 0>
                   = let {
                       ds1 :: ChessBoard.Player
                       = ChessBoard.Player
                           ChessBoard.isGameOver8
                           ChessBoard.isGameOver6
                           ChessBoard.isGameOver4
                           ww2
                           ChessBoard.isGameOver2
                     } in
                     let {
                       ds2 :: ChessBoard.Player
                       = ChessBoard.Player
                           ChessBoard.isGameOver8
                           ChessBoard.isGameOver6
                           ChessBoard.isGameOver4
                           ww1
                           ChessBoard.isGameOver2
                     } in
                     let {
                       wild :: ChessBoard.Game = ChessBoard.Game ww ds2 ds1
                     } in
                     let {
                       $j1 :: ChessBoard.GameOver <join 0>
                       = case ChessBoard.$wcycleBoardCheck
                                wild
                                w
                                ChessBoard.$fShowPlayer2
                                0# of wild1 {
                           GHC.Types.False -> ChessBoard.StaleMate
                           GHC.Types.True -> ChessBoard.Unfinished }
                     } in
                     case ChessBoard.isKingInCheck ww w of wild1 {
                       GHC.Types.False -> $j1
                       GHC.Types.True
                       -> case ChessBoard.$wcycleBoardCheck
                                 wild
                                 w
                                 ChessBoard.$fShowPlayer2
                                 0# of wild2 {
                            GHC.Types.False -> ChessBoard.CheckMate GHC.Types.True -> $j1 } }
                 } in
                 case GHC.Classes.$fEq[]_$c==
                        @ ChessBoard.ChessPiece
                        ChessBoard.$fEqChessPiece
                        ChessBoard.isGameOver1
                        ww1 of wild {
                   GHC.Types.False -> $j
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ ChessBoard.ChessPiece
                             ChessBoard.$fEqChessPiece
                             ChessBoard.isGameOver1
                             ww2 of wild1 {
                        GHC.Types.False -> $j
                        GHC.Types.True -> ChessBoard.StaleMate } }) -}
17e0b5888fc4dd6a8e4a2b67f2ee0e0d
  $wisOnlyKingsLeft ::
    ChessBoard.Pieces -> ChessBoard.Pieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Pieces)
                   (ww1 :: ChessBoard.Pieces) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ ChessBoard.ChessPiece
                        ChessBoard.$fEqChessPiece
                        ChessBoard.isGameOver1
                        ww of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ ChessBoard.ChessPiece
                        ChessBoard.$fEqChessPiece
                        ChessBoard.isGameOver1
                        ww1 }) -}
5b9e9ed923540800f4225659f12ef8b7
  $wisOpen ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,U><S,U><S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w :: ChessBoard.Board) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row w ww1)
                        ww of wild {
                   GHC.Maybe.Nothing -> GHC.Types.True
                   GHC.Maybe.Just a1 -> GHC.Types.False }) -}
407d2e5c6c17a8d9902997091f12d25e
  $wisValidBishopMovement ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww
                     } in
                     let {
                       x3 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT
                       -> case GHC.Prim.>=# x3 0# of lwild1 {
                            DEFAULT
                            -> case GHC.Prim./=#
                                      (GHC.Prim.negateInt# x2)
                                      (GHC.Prim.negateInt# x3) of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                            1#
                            -> case GHC.Prim./=# (GHC.Prim.negateInt# x2) x3 of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                       1#
                       -> case GHC.Prim.>=# x3 0# of lwild1 {
                            DEFAULT
                            -> case GHC.Prim./=# x2 (GHC.Prim.negateInt# x3) of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                            1#
                            -> case GHC.Prim./=# x2 x3 of lwild2 {
                                 DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
aef732ff49b7b1820fe3932b0a956791
  $wisValidKingMovement ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 ww
                     } in
                     let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           x3 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                         } in
                         case GHC.Prim.>=# x3 0# of lwild {
                           DEFAULT
                           -> case GHC.Prim.># (GHC.Prim.negateInt# x3) 1# of lwild1 {
                                DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                           1#
                           -> case GHC.Prim.># x3 1# of lwild1 {
                                DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT
                       -> case GHC.Prim.># (GHC.Prim.negateInt# x2) 1# of lwild1 {
                            DEFAULT -> $j1 1# -> GHC.Types.False }
                       1#
                       -> case GHC.Prim.># x2 1# of lwild1 {
                            DEFAULT -> $j1 1# -> GHC.Types.False } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
7fb60cbbb95cb9693176181a0efaca31
  $wisValidKnightMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U(U)><S,U><L,U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       x2 :: GHC.Prim.Int# = GHC.Prim.-# ww3 ww1
                     } in
                     let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           $j2 :: GHC.Types.Bool <join 0>
                           = case ww2 of wild { GHC.Types.I# x3 ->
                             case ww of wild1 { GHC.Types.I# y ->
                             let {
                               x4 :: GHC.Prim.Int# = GHC.Prim.-# x3 y
                             } in
                             case GHC.Prim.>=# x4 0# of lwild {
                               DEFAULT
                               -> case x4 of lwild1 {
                                    DEFAULT -> GHC.Types.False -1# -> GHC.Types.True }
                               1#
                               -> case x4 of wild2 {
                                    DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } } }
                         } in
                         case GHC.Prim.>=# x2 0# of lwild {
                           DEFAULT
                           -> case x2 of lwild1 { DEFAULT -> GHC.Types.True -2# -> $j2 }
                           1# -> case x2 of wild { DEFAULT -> GHC.Types.True 2# -> $j2 } }
                     } in
                     let {
                       $j2 :: GHC.Types.Bool <join 0>
                       = case ww2 of wild { GHC.Types.I# x3 ->
                         case ww of wild1 { GHC.Types.I# y ->
                         let {
                           x4 :: GHC.Prim.Int# = GHC.Prim.-# x3 y
                         } in
                         case GHC.Prim.>=# x4 0# of lwild {
                           DEFAULT
                           -> case x4 of lwild1 { DEFAULT -> GHC.Types.False -2# -> $j1 }
                           1#
                           -> case x4 of wild2 { DEFAULT -> GHC.Types.False 2# -> $j1 } } } }
                     } in
                     case GHC.Prim.>=# x2 0# of lwild {
                       DEFAULT -> case x2 of lwild1 { DEFAULT -> $j1 -1# -> $j2 }
                       1# -> case x2 of wild { DEFAULT -> $j1 1# -> $j2 } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
d9c814bdd705c8cf1e39e1cdb027f26a
  $wisValidMove ::
    GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (# GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String #)
  {- Arity: 4,
     Strictness: <S,1*U><L,1*U(U(U),U(U))><L,1*U(U(U),U(U))><L,U>,
     Inline: [2] -}
86c4c6d94f85c5eb485f479120e4b9df
  $wisValidMovement ::
    ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><S,1*U><L,U(U)><S,U><L,U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Color)
                   (ww1 :: ChessBoard.ChessPiece)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: ChessBoard.ColLoc)
                   (ww5 :: GHC.Prim.Int#) ->
                 case ww1 of wild {
                   ChessBoard.Pawn
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidPawnMovement ww ww7 ww3 ww9 ww5 } }
                   ChessBoard.Bishop
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidBishopMovement ww7 ww3 ww9 ww5 } }
                   ChessBoard.Knight
                   -> ChessBoard.$wisValidKnightMovement ww2 ww3 ww4 ww5
                   ChessBoard.Rook -> ChessBoard.$wisValidRookMovement ww2 ww3 ww4 ww5
                   ChessBoard.Queen
                   -> ChessBoard.$wisValidQueenMovement ww2 ww3 ww4 ww5
                   ChessBoard.King
                   -> case ww2 of ww6 { GHC.Types.I# ww7 ->
                      case ww4 of ww8 { GHC.Types.I# ww9 ->
                      ChessBoard.$wisValidKingMovement ww7 ww3 ww9 ww5 } } }) -}
0b1c60a6c10f890b14029e8a1410b062
  $wisValidMovementPiece ::
    ChessBoard.Piece
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(U,1*U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Piece)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: ChessBoard.RowLoc) ->
                 case GHC.Prim.<# ww 0# of lwild {
                   DEFAULT
                   -> case ww1 of wild { GHC.Types.I# x2 ->
                      case GHC.Prim.<# x2 0# of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.># ww 7# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.># x2 7# of lwild3 {
                                  DEFAULT
                                  -> case ww2 of wild1 { GHC.Types.I# x3 ->
                                     case GHC.Prim.<# x3 0# of lwild4 {
                                       DEFAULT
                                       -> case ww3 of wild2 { GHC.Types.I# x4 ->
                                          case GHC.Prim.<# x4 0# of lwild5 {
                                            DEFAULT
                                            -> case GHC.Prim.># x3 7# of lwild6 {
                                                 DEFAULT
                                                 -> case GHC.Prim.># x4 7# of lwild7 {
                                                      DEFAULT
                                                      -> case w of ww4 { ChessBoard.Piece ww5 ww6 ->
                                                         ChessBoard.$wisValidMovement
                                                           ww5
                                                           ww6
                                                           (GHC.Types.I# ww)
                                                           x2
                                                           wild1
                                                           x4 }
                                                      1# -> GHC.Types.False }
                                                 1# -> GHC.Types.False }
                                            1# -> GHC.Types.False } }
                                       1# -> GHC.Types.False } }
                                  1# -> GHC.Types.False }
                             1# -> GHC.Types.False }
                        1# -> GHC.Types.False } }
                   1# -> GHC.Types.False }) -}
f919dc09d22bc39012741c1cec5ec630
  $wisValidPawnAttack ::
    ChessBoard.Color
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 6, Strictness: <L,U><S,U><L,U(U)><S,U><L,U(U)><L,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: ChessBoard.RowLoc)
                   (w1 :: ChessBoard.Board) ->
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww ww2
                 } in
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = let {
                       $j1 :: GHC.Types.Bool <join 0>
                       = let {
                           $j2 :: GHC.Types.Bool <join 0>
                           = case ww3 of ww4 { GHC.Types.I# ww5 ->
                             case GHC.List.$w!!
                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                    (GHC.List.$w!! @ ChessBoard.Row w1 ww5)
                                    ww2 of wild {
                               GHC.Maybe.Nothing -> GHC.Types.False
                               GHC.Maybe.Just a1
                               -> case a1 of wild1 { ChessBoard.Piece enemyColor ds1 ->
                                  ChessBoard.$fEqColor_$c/= w enemyColor } } }
                         } in
                         case w of wild {
                           ChessBoard.Black -> $j2
                           ChessBoard.White
                           -> case ww3 of wild1 { GHC.Types.I# x3 ->
                              case ww1 of wild2 { GHC.Types.I# y ->
                              case GHC.Prim.-# x3 y of wild3 {
                                DEFAULT -> GHC.Types.False 1# -> $j2 } } } }
                     } in
                     case w of wild {
                       ChessBoard.Black
                       -> case ww1 of wild1 { GHC.Types.I# x3 ->
                          case ww3 of wild2 { GHC.Types.I# y ->
                          case GHC.Prim.-# x3 y of wild3 {
                            DEFAULT -> GHC.Types.False 1# -> $j1 } } }
                       ChessBoard.White -> $j1 }
                 } in
                 case GHC.Prim.>=# x2 0# of lwild {
                   DEFAULT
                   -> case x2 of lwild1 { DEFAULT -> GHC.Types.False -1# -> $j }
                   1# -> case x2 of wild { DEFAULT -> GHC.Types.False 1# -> $j } }) -}
df89f25f5dffec3b87847c74a3f2eeb1
  $wisValidPawnMovement ::
    ChessBoard.Color
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><S,U><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Color)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case GHC.Prim./=# ww ww2 of lwild {
                       DEFAULT
                       -> let {
                            $j1 :: GHC.Types.Bool <join 0>
                            = case w of wild {
                                ChessBoard.Black
                                -> GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# (GHC.Prim.+# ww3 1#) ww1)
                                ChessBoard.White
                                -> case ww1 of wild1 {
                                     DEFAULT
                                     -> GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.==# (GHC.Prim.-# ww3 1#) wild1)
                                     1#
                                     -> case ww3 of wild2 {
                                          DEFAULT -> GHC.Types.False
                                          2# -> GHC.Types.True
                                          3# -> GHC.Types.True } } }
                          } in
                          case w of wild {
                            ChessBoard.Black
                            -> case ww1 of wild1 {
                                 DEFAULT -> $j1
                                 6# -> case ww3 of wild2 { DEFAULT -> $j1 4# -> GHC.Types.True } }
                            ChessBoard.White -> $j1 }
                       1# -> GHC.Types.False }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case GHC.Prim.==# ww2 ww of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } }) -}
d74d3b2aa6156aefefd3a496cd0da834
  $wisValidPlayerMove ::
    ChessBoard.Board
    -> GHC.Prim.Int#
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Color
    -> (# GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String #)
  {- Arity: 6,
     Strictness: <L,U><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.Board)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.RowLoc)
                   (ww3 :: ChessBoard.ColLoc)
                   (ww4 :: ChessBoard.RowLoc)
                   (w :: ChessBoard.Color) ->
                 case GHC.Prim.># ww1 7# of lwild {
                   DEFAULT
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case GHC.Prim.># x2 7# of lwild1 {
                        DEFAULT
                        -> case GHC.Prim.<# ww1 0# of lwild2 {
                             DEFAULT
                             -> case GHC.Prim.<# x2 0# of lwild3 {
                                  DEFAULT
                                  -> case ww3 of wild1 { GHC.Types.I# x3 ->
                                     case GHC.Prim.># x3 7# of lwild4 {
                                       DEFAULT
                                       -> case ww4 of wild2 { GHC.Types.I# x4 ->
                                          case GHC.Prim.># x4 7# of lwild5 {
                                            DEFAULT
                                            -> case GHC.Prim.<# x3 0# of lwild6 {
                                                 DEFAULT
                                                 -> case GHC.Prim.<# x4 0# of lwild7 {
                                                      DEFAULT
                                                      -> case GHC.List.$w!!
                                                                @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                                                (GHC.List.$w!!
                                                                   @ ChessBoard.Row
                                                                   ww
                                                                   x2)
                                                                ww1 of wild3 {
                                                           GHC.Maybe.Nothing
                                                           -> (# GHC.Types.False,
                                                                 ChessBoard.isValidPlayerMove10 #)
                                                           GHC.Maybe.Just ipv
                                                           -> let {
                                                                $j :: (# GHC.Types.Bool,
                                                                         GHC.Maybe.Maybe
                                                                           GHC.Base.String #)
                                                                  <join 0>
                                                                = let {
                                                                    cs :: ChessBoard.ColLoc
                                                                    = GHC.Types.I# ww1
                                                                  } in
                                                                  case ChessBoard.$wisValidMove
                                                                         wild3
                                                                         (ChessBoard.Location
                                                                            cs
                                                                            wild)
                                                                         (ChessBoard.Location
                                                                            wild1
                                                                            wild2)
                                                                         ww of ww5 { (#,#) ww6 ww7 ->
                                                                  case ww6 of wild4 {
                                                                    GHC.Types.False -> ww5
                                                                    GHC.Types.True
                                                                    -> case GHC.List.$w!!
                                                                              @ (GHC.Maybe.Maybe
                                                                                   ChessBoard.Piece)
                                                                              (GHC.List.$w!!
                                                                                 @ ChessBoard.Row
                                                                                 ww
                                                                                 x4)
                                                                              x3 of wild5 {
                                                                         GHC.Maybe.Nothing
                                                                         -> case ChessBoard.isKingInCheck
                                                                                   (ChessBoard.$wchangeBoard
                                                                                      (ChessBoard.$wchangeBoard
                                                                                         ww
                                                                                         (GHC.Maybe.Nothing
                                                                                            @ ChessBoard.Piece)
                                                                                         cs
                                                                                         x2)
                                                                                      (GHC.List.$w!!
                                                                                         @ (GHC.Maybe.Maybe
                                                                                              ChessBoard.Piece)
                                                                                         (GHC.List.$w!!
                                                                                            @ ChessBoard.Row
                                                                                            ww
                                                                                            x2)
                                                                                         ww1)
                                                                                      (GHC.Types.I#
                                                                                         x3)
                                                                                      x4)
                                                                                   w of wild6 {
                                                                              GHC.Types.False
                                                                              -> (# GHC.Types.True,
                                                                                    GHC.Maybe.Nothing
                                                                                      @ GHC.Base.String #)
                                                                              GHC.Types.True
                                                                              -> (# GHC.Types.False,
                                                                                    ChessBoard.isValidPlayerMove7 #) }
                                                                         GHC.Maybe.Just a1
                                                                         -> case ChessBoard.isKingInCheck
                                                                                   (ChessBoard.$wchangeBoard
                                                                                      (ChessBoard.$wchangeBoard
                                                                                         ww
                                                                                         (GHC.Maybe.Nothing
                                                                                            @ ChessBoard.Piece)
                                                                                         cs
                                                                                         x2)
                                                                                      (GHC.List.$w!!
                                                                                         @ (GHC.Maybe.Maybe
                                                                                              ChessBoard.Piece)
                                                                                         (GHC.List.$w!!
                                                                                            @ ChessBoard.Row
                                                                                            ww
                                                                                            x2)
                                                                                         ww1)
                                                                                      (GHC.Types.I#
                                                                                         x3)
                                                                                      x4)
                                                                                   w of wild6 {
                                                                              GHC.Types.False
                                                                              -> (# GHC.Types.True,
                                                                                    GHC.Maybe.Nothing
                                                                                      @ GHC.Base.String #)
                                                                              GHC.Types.True
                                                                              -> (# GHC.Types.False,
                                                                                    ChessBoard.isValidPlayerMove7 #) } } } }
                                                              } in
                                                              case w of wild4 {
                                                                ChessBoard.Black
                                                                -> case ipv of wild5 { ChessBoard.Piece ds1 ds2 ->
                                                                   case ds1 of wild6 {
                                                                     ChessBoard.Black -> $j
                                                                     ChessBoard.White
                                                                     -> (# GHC.Types.False,
                                                                           ChessBoard.isValidPlayerMove10 #) } }
                                                                ChessBoard.White
                                                                -> case ipv of wild5 { ChessBoard.Piece ds1 ds2 ->
                                                                   case ds1 of wild6 {
                                                                     ChessBoard.Black
                                                                     -> (# GHC.Types.False,
                                                                           ChessBoard.isValidPlayerMove10 #)
                                                                     ChessBoard.White -> $j } } } }
                                                      1#
                                                      -> (# GHC.Types.False,
                                                            ChessBoard.isValidPlayerMove4 #) }
                                                 1#
                                                 -> (# GHC.Types.False,
                                                       ChessBoard.isValidPlayerMove4 #) }
                                            1#
                                            -> (# GHC.Types.False,
                                                  ChessBoard.isValidPlayerMove4 #) } }
                                       1#
                                       -> (# GHC.Types.False, ChessBoard.isValidPlayerMove4 #) } }
                                  1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }
                             1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }
                        1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) } }
                   1# -> (# GHC.Types.False, ChessBoard.isValidPlayerMove1 #) }) -}
53f28c3411c0061a1a74d1a1a3026bb1
  $wisValidQueenMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S),U(U)><S,U><S(S),U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case ww of ww4 { GHC.Types.I# ww5 ->
                     case ww2 of ww6 { GHC.Types.I# ww7 ->
                     case ChessBoard.$wisValidBishopMovement ww5 ww1 ww7 ww3 of wild {
                       GHC.Types.False
                       -> case GHC.Prim.==# ww3 ww1 of lwild {
                            DEFAULT
                            -> case GHC.Prim.-# ww3 ww1 of wild1 {
                                 DEFAULT
                                 -> case GHC.Prim.-# ww7 ww5 of wild2 {
                                      DEFAULT -> GHC.Types.False 0# -> GHC.Types.True }
                                 0# -> GHC.Types.True }
                            1#
                            -> case GHC.Prim.==# ww7 ww5 of lwild1 {
                                 DEFAULT
                                 -> case GHC.Prim.-# ww3 ww1 of wild1 {
                                      DEFAULT
                                      -> case GHC.Prim.-# ww7 ww5 of wild2 {
                                           DEFAULT -> GHC.Types.False 0# -> GHC.Types.True }
                                      0# -> GHC.Types.True }
                                 1# -> GHC.Types.False } }
                       GHC.Types.True -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
9f790fbc332a16ec74daf0ed95ab099f
  $wisValidRookMovement ::
    ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U(U)><S,U><L,U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (ww :: ChessBoard.ColLoc)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case GHC.Prim.-# ww3 ww1 of wild {
                       DEFAULT
                       -> case ww2 of wild1 { GHC.Types.I# x2 ->
                          case ww of wild2 { GHC.Types.I# y ->
                          case GHC.Prim.-# x2 y of wild3 {
                            DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } } }
                       0# -> GHC.Types.True }
                 } in
                 case GHC.Prim.==# ww3 ww1 of lwild {
                   DEFAULT -> $j
                   1#
                   -> case ww2 of wild { GHC.Types.I# x2 ->
                      case ww of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.==# x2 y of lwild1 {
                        DEFAULT -> $j 1# -> GHC.Types.False } } } }) -}
e4e2b32097d6f86f90b54c0bf8afc9ec
  $wmovePiece ::
    ChessBoard.Board
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> GHC.Prim.Int#
    -> ChessBoard.Board
  {- Arity: 5, Strictness: <L,U><L,U(U)><L,U(U)><L,1*U(U)><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (ww :: ChessBoard.ColLoc)
                   (ww1 :: ChessBoard.RowLoc)
                   (ww2 :: ChessBoard.ColLoc)
                   (ww3 :: GHC.Prim.Int#) ->
                 ChessBoard.$wchangeBoard
                   (case ww1 of ww4 { GHC.Types.I# ww5 ->
                    ChessBoard.$wchangeBoard
                      w
                      (GHC.Maybe.Nothing @ ChessBoard.Piece)
                      ww
                      ww5 })
                   (case ww of ww4 { GHC.Types.I# ww5 ->
                    case ww1 of ww6 { GHC.Types.I# ww7 ->
                    GHC.List.$w!!
                      @ (GHC.Maybe.Maybe ChessBoard.Piece)
                      (GHC.List.$w!! @ ChessBoard.Row w ww7)
                      ww5 } })
                   ww2
                   ww3) -}
d69a3a021266505dfb77d8af3b534ef7
  $wprintCol :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT -> ChessBoard.$fShowLocation16
                   0# -> ChessBoard.$fShowLocation14
                   1# -> ChessBoard.$fShowChessPiece9
                   2# -> ChessBoard.$fShowLocation12
                   3# -> ChessBoard.$fShowLocation10
                   4# -> ChessBoard.$fShowLocation8
                   5# -> ChessBoard.$fShowLocation6
                   6# -> ChessBoard.$fShowLocation4
                   7# -> ChessBoard.$fShowLocation2 }) -}
9569c90c64f4e5f100e718996c832138
  $wprintPlayerScore ::
    GHC.Base.String
    -> ChessBoard.Color -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   ChessBoard.printPlayerScore3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ww
                      (GHC.CString.unpackAppendCString#
                         ChessBoard.printPlayerScore2
                         (let {
                            n8 :: [GHC.Types.Char]
                            = GHC.CString.unpackAppendCString#
                                ChessBoard.printPlayerScore1
                                (case ww2 of ww3 { GHC.Types.I# ww4 ->
                                 case GHC.Show.$wshowSignedInt
                                        0#
                                        ww4
                                        (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                                 GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                          } in
                          case ww1 of wild {
                            ChessBoard.Black
                            -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowChessPiece9 n8
                            ChessBoard.White
                            -> GHC.Base.++ @ GHC.Types.Char ChessBoard.$fShowColor2 n8 })))) -}
764a6804fc7554c86d828293f968dc2a
  $wprintRow ::
    GHC.Prim.Int#
    -> ChessBoard.Board -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: ChessBoard.Board) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        (GHC.Prim.+# ww 1#)
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 case GHC.Base.++_$s++
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           ChessBoard.printBoard3
                           (case GHC.Base.map
                                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                   @ [GHC.Types.Char]
                                   ChessBoard.printMaybePiece
                                   (GHC.List.$w!! @ ChessBoard.Row w ww) of wild {
                              [] -> ChessBoard.printBoard1
                              : x2 xs
                              -> ChessBoard.printBoard_go1
                                   (GHC.Types.:
                                      @ GHC.Base.String
                                      x2
                                      (Data.OldList.prependToAll
                                         @ GHC.Base.String
                                         ChessBoard.colSep
                                         xs)) }))
                        ww5
                        ww6 of ww1 { : ww2 ww3 ->
                 (# ww2, ww3 #) } }) -}
f80eeacf6592c60a158546859b646b59
  $wprintScore ::
    GHC.Base.String
    -> ChessBoard.Color
    -> GHC.Types.Int
    -> ChessBoard.Player
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,1*U><L,1*U><L,1*U(U)><L,1*U(1*U,1*U,A,A,1*U(U))>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: ChessBoard.Player) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ChessBoard.$wprintPlayerScore ww ww1 ww2)
                   (GHC.CString.unpackAppendCString#
                      ChessBoard.printScore1
                      (case ww3 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                       ChessBoard.$wprintPlayerScore ww5 ww6 ww9 }))) -}
2a80a4518c4555f5c930588844d3489d
  $wupdateActive ::
    GHC.Base.String
    -> ChessBoard.Color
    -> ChessBoard.Pieces
    -> ChessBoard.Pieces
    -> GHC.Types.Int
    -> ChessBoard.ChessPiece
    -> (# GHC.Base.String, ChessBoard.Color, ChessBoard.Pieces,
          ChessBoard.Pieces, GHC.Types.Int #)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: ChessBoard.Color)
                   (ww2 :: ChessBoard.Pieces)
                   (ww3 :: ChessBoard.Pieces)
                   (ww4 :: GHC.Types.Int)
                   (w :: ChessBoard.ChessPiece) ->
                 (# ww, ww1, ww2,
                    let {
                      exit :: ChessBoard.Pieces <join 0>
                      = ChessBoard.removePiece ww3 (GHC.Maybe.Nothing @ GHC.Types.Int)
                    } in
                    let {
                      exit1 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit2 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit3 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit4 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit5 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    let {
                      exit6 :: GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 1> {- Arity: 1, Strictness: <L,U> -}
                      = \ (eta :: GHC.Prim.Int#)[OneShot] ->
                        ChessBoard.removePiece
                          ww3
                          (GHC.Maybe.Just @ GHC.Types.Int (GHC.Types.I# eta))
                    } in
                    letrec {
                      go1 :: [ChessBoard.ChessPiece]
                             -> GHC.Prim.Int# -> ChessBoard.Pieces
                        <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                      = \ (ds1 :: [ChessBoard.ChessPiece]) (eta :: GHC.Prim.Int#) ->
                        case ds1 of wild {
                          [] -> exit
                          : y ys
                          -> case w of wild1 {
                               ChessBoard.Pawn
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Pawn -> exit1 eta }
                               ChessBoard.Bishop
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Bishop -> exit2 eta }
                               ChessBoard.Knight
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Knight -> exit3 eta }
                               ChessBoard.Rook
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Rook -> exit4 eta }
                               ChessBoard.Queen
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.Queen -> exit5 eta }
                               ChessBoard.King
                               -> case y of wild2 {
                                    DEFAULT -> go1 ys (GHC.Prim.+# eta 1#)
                                    ChessBoard.King -> exit6 eta } } }
                    } in
                    go1 ww3 0#,
                    ww4 #)) -}
f39b4cc02c27fe09aab027529f469f3e
  $wupdateBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (# ChessBoard.Board, GHC.Maybe.Maybe ChessBoard.Piece #)
  {- Arity: 4, Strictness: <S,U><L,1*U(U(U),U(U))><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#) ->
                 case GHC.List.$w!!
                        @ (GHC.Maybe.Maybe ChessBoard.Piece)
                        (GHC.List.$w!! @ ChessBoard.Row w ww1)
                        ww of wild {
                   GHC.Maybe.Nothing
                   -> (# case w1 of ww2 { ChessBoard.Location ww3 ww4 ->
                         ChessBoard.$wmovePiece w ww3 ww4 (GHC.Types.I# ww) ww1 },
                         GHC.Maybe.Nothing @ ChessBoard.Piece #)
                   GHC.Maybe.Just a1
                   -> (# case w1 of ww2 { ChessBoard.Location ww3 ww4 ->
                         ChessBoard.$wmovePiece w ww3 ww4 (GHC.Types.I# ww) ww1 },
                         wild #) }) -}
4e61a81977ac1a14260104a493ede8b9
  $wxs ::
    GHC.Prim.Int#
    -> (# ChessBoard.ChessPiece, [ChessBoard.ChessPiece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
0dcced9069f2af0f5077c7b45337505f
  $wxs1 ::
    GHC.Prim.Int#
    -> (# GHC.Maybe.Maybe ChessBoard.Piece,
          [GHC.Maybe.Maybe ChessBoard.Piece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
555ca7215c10e750e357caa7483af60c
  $wxs2 ::
    GHC.Prim.Int#
    -> (# ChessBoard.ChessPiece, [ChessBoard.ChessPiece] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
577092671970798aca5dfe73cd594681
  $wxs3 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
57501d93c380cd4278b7670c78ec4e12
  type Board = [ChessBoard.Row]
51607fc8dbe32561da396ec7bbcc0615
  data ChessPiece = Pawn | Bishop | Knight | Rook | Queen | King
4d2f9eb496243069f6f7fa596bc08890
  type ColLoc = GHC.Types.Int
8c02f1645e49ff56e8ac2e9604a2be0b
  data Color = Black | White
fb216e9851a09c8add07ec52ee0ffa4b
  data Direction
    = Forward
    | Backward
    | Leftt
    | Rightt
    | DiagFR
    | DiagBR
    | DiagFL
    | DiagBL
bfce426340fad4ef427fa95511c74a14
  data Game
    = Game {gameBoard :: ChessBoard.Board,
            gamePlayer1 :: ChessBoard.Player,
            gamePlayer2 :: ChessBoard.Player}
866391a80495c905565168715eaeb98b
  data GameOver = CheckMate | StaleMate | Unfinished
61763d609e56610dc321c7932fa09a95
  data Location = Location ChessBoard.ColLoc ChessBoard.RowLoc
1911fdf70f07e10faf3d52dd1b71ed25
  data Piece = Piece ChessBoard.Color ChessBoard.ChessPiece
3d3885bdc05872f8afdbc1279418b82d
  type Pieces = [ChessBoard.ChessPiece]
0c8660847805700d74fd94c21ab37e42
  data Player
    = Player {name :: GHC.Base.String,
              playerColor :: ChessBoard.Color,
              captured :: ChessBoard.Pieces,
              active :: ChessBoard.Pieces,
              score :: GHC.Types.Int}
9fb428a8e479b282c88a06228d6052f0
  type Row = [GHC.Maybe.Maybe ChessBoard.Piece]
4914dcb02a6fb8ad0fa41ddf9ab61abf
  type RowLoc = GHC.Types.Int
0c8660847805700d74fd94c21ab37e42
  active :: ChessBoard.Player -> ChessBoard.Pieces
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Player) ->
                 case ds1 of wild { ChessBoard.Player ds2 ds3 ds4 ds5 ds6 ->
                 ds5 }) -}
98f41fd4633987fa2b8f67a1203126f7
  baseRow :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Rook
                   ChessBoard.baseRow1) -}
eea5b43e51eb9e17d7b6153827ccdcdd
  baseRow1 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Knight
                   ChessBoard.baseRow2) -}
bd18ae98e3e762066842a8d8db4ceb4b
  baseRow2 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Bishop
                   ChessBoard.baseRow3) -}
e39fcfdd053e41cac8f7c1d3aa2f4fd1
  baseRow3 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Queen
                   ChessBoard.baseRow4) -}
3b58cc309f23c840f61bccbe65be90fc
  baseRow4 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.King
                   ChessBoard.baseRow5) -}
0a040b9a7f10b7fd8e98628b96f0a3c5
  baseRow5 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Bishop
                   ChessBoard.baseRow6) -}
832717a9b2c8d38905f604d8d86d391f
  baseRow6 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Knight
                   ChessBoard.baseRow7) -}
e530e88e5633a4af92483133e7386f62
  baseRow7 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.Rook
                   (GHC.Types.[] @ ChessBoard.ChessPiece)) -}
b531c804088004af26ea4a23f791f227
  blackPlayer :: ChessBoard.Player
  {- Strictness: m,
     Unfolding: (ChessBoard.Player
                   ChessBoard.blackPlayer2
                   ChessBoard.Black
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   ChessBoard.blackPlayer1
                   ChessBoard.$fShowPlayer2) -}
3e7be333ff7199a94a160f01a2248fcf
  blackPlayer1 :: [ChessBoard.ChessPiece]
  {- Unfolding: (case ChessBoard.$wxs 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ ChessBoard.ChessPiece ww1 ww2 }) -}
2d11039024db7a7bbc9086cc1f7fdb08
  blackPlayer2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.blackPlayer3) -}
90df37657349ed2e53d2e56eecb960f5
  blackPlayer3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player 2"#) -}
0c8660847805700d74fd94c21ab37e42
  captured :: ChessBoard.Player -> ChessBoard.Pieces
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSLL),1*U(A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Player) ->
                 case ds1 of wild { ChessBoard.Player ds2 ds3 ds4 ds5 ds6 ->
                 ds4 }) -}
2f62b7dd717573ec8804c3d775c7d95b
  changeBoard ::
    ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wchangeBoard w w1 w2 ww1 }) -}
d7c1e8840b21a9c0efbd69a3a095af1d
  checkPawnPromotion ::
    ChessBoard.Game
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(SLL),1*U(1*U,A,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(A,1*U(1*U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww6 of ww9 { GHC.Types.I# ww10 ->
                 case w2 of ww11 { ChessBoard.Location ww12 ww13 ->
                 ChessBoard.$wcheckPawnPromotion ww1 ww8 ww10 ww13 } } } } }) -}
4d3c2ce97cda59eda3ec37da8f11d04e
  checkPiece ::
    ChessBoard.Board
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 3, Strictness: <L,1*U><S(S),1*U(U)><L,1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.ColLoc)
                   (w2 :: ChessBoard.RowLoc) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wcheckPiece w ww1 w2 }) -}
d7b83b876abe145fd3f0a5323c6cb208
  colSep :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# ChessBoard.colSep1) -}
f1b16eb558d343a7d5e47b776da27e74
  colSep1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("|"#) -}
639267ef52ca305cb31bbdb2dee62971
  colorPiece ::
    ChessBoard.Color -> ChessBoard.ChessPiece -> ChessBoard.Piece
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True) ChessBoard.Piece -}
682880095074056a02d0c2de479332eb
  cycleBoardCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,1*U(U,A,A)><L,U><L,1*U(1*U)><S(S),1*U(1*U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wcycleBoardCheck w w1 w2 ww1 }) -}
499b77d2a706fe002ff7ef0e3fef6b77
  cycleMoveCheck ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <S(SLL),1*U(U,A,A)><L,U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 case w3 of ww6 { GHC.Types.I# ww7 ->
                 ChessBoard.$wcycleMoveCheck ww1 w1 ww5 ww7 } } }) -}
8d53572d9f93d83965f72a1684ef35db
  emptyRow :: ChessBoard.Row
  {- Unfolding: (case ChessBoard.$wxs1 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Maybe.Maybe ChessBoard.Piece) ww1 ww2 }) -}
a313637afc06bee06ecd2077fba75106
  firstPiece ::
    ChessBoard.Direction
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Board
    -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 4, Strictness: <L,U><S(S),1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Direction)
                   (w1 :: ChessBoard.ColLoc)
                   (w2 :: ChessBoard.RowLoc)
                   (w3 :: ChessBoard.Board) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wfirstPiece w ww1 w2 w3 }) -}
67783c303aab52711ca75c2bb583ed08
  fromPieceToChessPiece :: ChessBoard.Piece -> ChessBoard.ChessPiece
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Piece) ->
                 case ds1 of wild { ChessBoard.Piece ds2 cp -> cp }) -}
83d99b0d8c70073c5e1deb5fdfe16d64
  fromPieceToColor :: ChessBoard.Piece -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Piece) ->
                 case ds1 of wild { ChessBoard.Piece color ds2 -> color }) -}
bb000d47073b5e63790b844cc0bfab57
  game :: ChessBoard.Game
  {- Strictness: m,
     Unfolding: (ChessBoard.Game
                   ChessBoard.startBoard
                   ChessBoard.whitePlayer
                   ChessBoard.blackPlayer) -}
bfce426340fad4ef427fa95511c74a14
  gameBoard :: ChessBoard.Game -> ChessBoard.Board
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Game) ->
                 case ds1 of wild { ChessBoard.Game ds2 ds3 ds4 -> ds2 }) -}
bfce426340fad4ef427fa95511c74a14
  gamePlayer1 :: ChessBoard.Game -> ChessBoard.Player
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(A,1*U(U,U,U,U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Game) ->
                 case ds1 of wild { ChessBoard.Game ds2 ds3 ds4 -> ds3 }) -}
bfce426340fad4ef427fa95511c74a14
  gamePlayer2 :: ChessBoard.Game -> ChessBoard.Player
  RecSel Left ChessBoard.Game
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS),1*U(A,A,1*U(U,U,U,U,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Game) ->
                 case ds1 of wild { ChessBoard.Game ds2 ds3 ds4 -> ds4 }) -}
526760f8cb6cd5bb15c2b898d98a98a2
  getKingInBoard ::
    ChessBoard.Board
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 4, Strictness: <S,U><L,U><S(S),1*U(1*U)><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 ChessBoard.$wgetKingInBoard w w1 ww1 ww3 } }) -}
f269e109686054c3ff480418b2027901
  getKingLocation ::
    ChessBoard.Board
    -> ChessBoard.Color -> GHC.Maybe.Maybe ChessBoard.Location
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (board :: ChessBoard.Board) (color :: ChessBoard.Color) ->
                 ChessBoard.getKingInBoard
                   board
                   color
                   ChessBoard.$fShowPlayer2
                   ChessBoard.$fShowPlayer2) -}
82470edcd0233b3bbfb2874cf5b08ac6
  getNextCol ::
    ChessBoard.ColLoc -> ChessBoard.Direction -> ChessBoard.ColLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.ColLoc) (w1 :: ChessBoard.Direction) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of wild {
                   DEFAULT -> GHC.Types.I# ww1
                   ChessBoard.Leftt -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.Rightt -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagFR -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagBR -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.DiagFL -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.DiagBL -> GHC.Types.I# (GHC.Prim.-# ww1 1#) } }) -}
ce8c47ac8e587689c3c458f09744a45b
  getNextRow ::
    ChessBoard.RowLoc -> ChessBoard.Direction -> ChessBoard.RowLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.RowLoc) (w1 :: ChessBoard.Direction) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of wild {
                   DEFAULT -> GHC.Types.I# (GHC.Prim.+# ww1 1#)
                   ChessBoard.Backward -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.Leftt -> GHC.Types.I# ww1
                   ChessBoard.Rightt -> GHC.Types.I# ww1
                   ChessBoard.DiagBR -> GHC.Types.I# (GHC.Prim.-# ww1 1#)
                   ChessBoard.DiagBL -> GHC.Types.I# (GHC.Prim.-# ww1 1#) } }) -}
8fcc6f556ba059dfd91e5265937650ba
  isAnyBishopMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyBishopMove w w1 ww1 w3 }) -}
7c39dfc5fdfd58e5d846956baaf1ab48
  isAnyKingMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyKingMove ww1 w1 ww5 w3 } }) -}
41b542500b5a03a75fbb9a9ef23f1d89
  isAnyKnightMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyKnightMove ww1 w1 ww5 w3 } }) -}
47a24277b49b2ca1321eb30a81405d95
  isAnyMove :: ChessBoard.Game -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (gm :: ChessBoard.Game) (color :: ChessBoard.Color) ->
                 ChessBoard.cycleBoardCheck
                   gm
                   color
                   ChessBoard.$fShowPlayer2
                   ChessBoard.$fShowPlayer2) -}
fd4f0860e9708dac7cb605c0497fba49
  isAnyMoveRecurse ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> ChessBoard.Direction
    -> GHC.Types.Bool
  {- Arity: 7,
     Strictness: <L,1*U(U,A,A)><L,U><L,1*U(U)><L,U(U)><S(S),1*U(U)><L,1*U(U)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc)
                   (w4 :: ChessBoard.ColLoc)
                   (w5 :: ChessBoard.RowLoc)
                   (w6 :: ChessBoard.Direction) ->
                 case w4 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyMoveRecurse w w1 w2 w3 ww1 w5 w6 }) -}
125963b219fbe9976a6ab7a052bd8a20
  isAnyPawnMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 ChessBoard.$wisAnyPawnMove ww1 w1 ww5 w3 } }) -}
4022b229ee7dbb5f61cadce2828064a8
  isAnyQueenMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyQueenMove w w1 ww1 w3 }) -}
af6ebb417a64ce9e77d33f3ed82ccd3d
  isAnyRookMove ::
    ChessBoard.Game
    -> ChessBoard.Color
    -> ChessBoard.ColLoc
    -> ChessBoard.RowLoc
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(U,A,A)><L,U><S(S),1*U(U)><L,U(U)>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Color)
                   (w2 :: ChessBoard.ColLoc)
                   (w3 :: ChessBoard.RowLoc) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 ChessBoard.$wisAnyRookMove w w1 ww1 w3 }) -}
e8467e45a54b5780122f34d5bc0a3c2c
  isClearPath ::
    ChessBoard.Location
    -> ChessBoard.Location -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Location)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisClearPath ww4 ww6 ww11 ww13 w2 } } } } } }) -}
9288e4562f385982fd8928f64eadb5c0
  isEnemyPiece ::
    ChessBoard.Color
    -> GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds1 :: ChessBoard.Color)
                   (ds2 :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds2 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just ds3
                   -> case ds3 of wild1 { ChessBoard.Piece enemyColor ds4 ->
                      ChessBoard.$fEqColor_$c/= ds1 enemyColor } }) -}
71aa2f0d078a4511fc20be637942e68d
  isGameOver ::
    ChessBoard.Game -> ChessBoard.Color -> ChessBoard.GameOver
  {- Arity: 2,
     Strictness: <S(LS(LLLSL)S),1*U(U,1*U(A,A,A,1*U,A),1*U(A,A,A,1*U,A))><L,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Game) (w1 :: ChessBoard.Color) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case ww2 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                 case ww3 of ww10 { ChessBoard.Player ww11 ww12 ww13 ww14 ww15 ->
                 ChessBoard.$wisGameOver ww1 ww8 ww14 w1 } } }) -}
55950057489ee6ca2ed13e15fdffd2ef
  isGameOver1 :: [ChessBoard.ChessPiece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.ChessPiece
                   ChessBoard.King
                   (GHC.Types.[] @ ChessBoard.ChessPiece)) -}
a88fede1a3d1206ec108b1091a8a413a
  isGameOver2 :: GHC.Types.Int
  {- Unfolding: (Control.Exception.Base.absentError
                   @ GHC.Types.Int
                   ChessBoard.isGameOver3) -}
ca526d5410f8eeec7d4e2156db6af9dd
  isGameOver3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww Int"#) -}
798d1804507d97ef63509ab42e155206
  isGameOver4 :: ChessBoard.Pieces
  {- Unfolding: (Control.Exception.Base.absentError
                   @ ChessBoard.Pieces
                   ChessBoard.isGameOver5) -}
3b2fb818ae77a5765d1cd50775196d1c
  isGameOver5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww Pieces"#) -}
f2d0d2335ed99b95814800aa124f5b41
  isGameOver6 :: ChessBoard.Color
  {- Unfolding: (Control.Exception.Base.absentError
                   @ ChessBoard.Color
                   ChessBoard.isGameOver7) -}
e9b19021501802cb6221685f00d59a09
  isGameOver7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww Color"#) -}
b6c76f8cefa7f641482947c8fda0a9d2
  isGameOver8 :: GHC.Base.String
  {- Unfolding: (Control.Exception.Base.absentError
                   @ GHC.Base.String
                   ChessBoard.isGameOver9) -}
87724735916f1d77fd9bc5a7c70a6817
  isGameOver9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww String"#) -}
5170d8949c2b61787bc53630906850f0
  isKingInCheck ::
    ChessBoard.Board -> ChessBoard.Color -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (board :: ChessBoard.Board)
                   (turn :: ChessBoard.Color) ->
                 let {
                   kingLoc :: GHC.Maybe.Maybe ChessBoard.Location
                   = ChessBoard.$wgetKingInBoard board turn 0# 0#
                 } in
                 case ChessBoard.isKingInDiagCheck kingLoc turn board of wild {
                   GHC.Types.False
                   -> case ChessBoard.isKingInStraightCheck
                             kingLoc
                             turn
                             board of wild1 {
                        GHC.Types.False
                        -> case ChessBoard.isKingInKnightCheck
                                  kingLoc
                                  turn
                                  board of wild2 {
                             GHC.Types.False
                             -> case ChessBoard.isKingInPawnCheck kingLoc turn board of wild3 {
                                  GHC.Types.False -> ChessBoard.isKingInKingCheck kingLoc turn board
                                  GHC.Types.True -> GHC.Types.True }
                             GHC.Types.True -> GHC.Types.True }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
7dd845dd2161d82ef891cf53cc037c49
  isKingInDiagCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
2ae9745d71135b9572cfb3921d8773fa
  isKingInKingCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
2a932af07e1a9072e2b17280e0dcbf5e
  isKingInKnightCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
79d4cdd2d3050bba1180b13c1cc82ca9
  isKingInPawnCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
e31c6816a3d9c6dbcbcd365d6d010d06
  isKingInStraightCheck ::
    GHC.Maybe.Maybe ChessBoard.Location
    -> ChessBoard.Color -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
7fbfab9260698f2012adc7f181115a66
  isKingLeftInCheck ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <S,U><L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (board :: ChessBoard.Board)
                   (ls :: ChessBoard.Location)
                   (le :: ChessBoard.Location)
                   (turnColor :: ChessBoard.Color) ->
                 case ChessBoard.updateBoard board ls le of wild { (,) x2 ds1 ->
                 ChessBoard.isKingInCheck x2 turnColor }) -}
04b181796d8b181ba71ffc465d930ef4
  isOnlyKingsLeft :: ChessBoard.Game -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LLLSL)S),1*U(A,1*U(A,A,A,1*U,A),1*U(A,A,A,1*U,A))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Game) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case ww2 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                 case ww3 of ww10 { ChessBoard.Player ww11 ww12 ww13 ww14 ww15 ->
                 ChessBoard.$wisOnlyKingsLeft ww8 ww14 } } }) -}
ffee6fd18ce6273019181f51a70c658f
  isOpen :: ChessBoard.Location -> ChessBoard.Board -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 ChessBoard.$wisOpen ww4 ww6 w1 } } }) -}
1a61dbedb074d1d7c8d6b26e64c8513a
  isValidBishopMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case ww5 of ww8 { GHC.Types.I# ww9 ->
                 case w2 of ww10 { ChessBoard.Location ww11 ww12 ->
                 case ww11 of ww13 { GHC.Types.I# ww14 ->
                 case ww12 of ww15 { GHC.Types.I# ww16 ->
                 case ChessBoard.$wisValidBishopMovement ww7 ww9 ww14 ww16 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove7)
                   GHC.Types.True
                   -> case ChessBoard.$wisClearPath ww7 ww9 ww14 ww16 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                       ww14 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds1
                                  -> case ds1 of wild4 { ChessBoard.Piece enemyColor ds2 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
3a4f6db0fe1ed6c950978996af39e536
  isValidBishopMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove2) -}
2c4b419c012464698b163cdf2e0aef69
  isValidBishopMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove3) -}
c626ec92e49e09d0dbadc10fca88559e
  isValidBishopMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("You cannot capture your own piece!"#) -}
de6282dac4e95dba895e0de4aba3aa6f
  isValidBishopMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove5) -}
dc41b8e308f79a8e4f8a1c3266957fb5
  isValidBishopMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove6) -}
cf4e4806bcd8233e4f52e5ebc5efd121
  isValidBishopMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("The path is not clear!"#) -}
a97fa64fc73172f1e4e58501bbbb1546
  isValidBishopMove7 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidBishopMove8) -}
62af27b63aa86c9b500b3aab7682bd98
  isValidBishopMove8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidBishopMove9) -}
f6802b2985120708884f1928a20e1dfa
  isValidBishopMove9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid bishop movement!"#) -}
c00f65d60dac9d606189cb1dd2a0c582
  isValidBishopMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidBishopMovement
                   ww4
                   ww6
                   ww11
                   ww13 } } } } } }) -}
9cc501200e802594a6150a5912733260
  isValidKingMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case ww5 of ww8 { GHC.Types.I# ww9 ->
                 case w2 of ww10 { ChessBoard.Location ww11 ww12 ->
                 case ww11 of ww13 { GHC.Types.I# ww14 ->
                 case ww12 of ww15 { GHC.Types.I# ww16 ->
                 case ChessBoard.$wisValidKingMovement ww7 ww9 ww14 ww16 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidKingMove1)
                   GHC.Types.True
                   -> case GHC.List.$w!!
                             @ (GHC.Maybe.Maybe ChessBoard.Piece)
                             (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                             ww14 of wild1 {
                        GHC.Maybe.Nothing
                        -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                        GHC.Maybe.Just a1
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                             GHC.Maybe.Just ds1
                             -> case ds1 of wild3 { ChessBoard.Piece enemyColor ds2 ->
                                case ww1 of wild4 {
                                  ChessBoard.Black
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                       ChessBoard.White
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                                  ChessBoard.White
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                       ChessBoard.White
                                       -> (GHC.Types.False,
                                           ChessBoard.isValidBishopMove1) } } } } } } } } } } } } }) -}
93bab132f5a7287b49ea330c33e4f73a
  isValidKingMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidKingMove2) -}
1c1065190960b503a5b59c12e79ef2b6
  isValidKingMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidKingMove3) -}
4b301e03fba4a065ac8f9f2904c4c46d
  isValidKingMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid king movement!"#) -}
3ef8bbd2d6476991c504d257899b074d
  isValidKingMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidKingMovement ww4 ww6 ww11 ww13 } } } } } }) -}
05edbf756c1b4379237eaa6d578dbc5d
  isValidKnightMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidKnightMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidKnightMove1)
                   GHC.Types.True
                   -> case ww9 of ww13 { GHC.Types.I# ww14 ->
                      case GHC.List.$w!!
                             @ (GHC.Maybe.Maybe ChessBoard.Piece)
                             (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                             ww14 of wild1 {
                        GHC.Maybe.Nothing
                        -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                        GHC.Maybe.Just a1
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww14 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                             GHC.Maybe.Just ds1
                             -> case ds1 of wild3 { ChessBoard.Piece enemyColor ds2 ->
                                case ww1 of wild4 {
                                  ChessBoard.Black
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                       ChessBoard.White
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                                  ChessBoard.White
                                  -> case enemyColor of wild5 {
                                       ChessBoard.Black
                                       -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                       ChessBoard.White
                                       -> (GHC.Types.False,
                                           ChessBoard.isValidBishopMove1) } } } } } } } } } } } }) -}
cdb33a54e1e6f1221663094fa85aab51
  isValidKnightMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidKnightMove2) -}
412e5d8d48afcaebddb8a0be766efa9a
  isValidKnightMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidKnightMove3) -}
fd83a6175072c92b7967a0188ee5f485
  isValidKnightMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid knight movement!"#) -}
3a5da5b76a45b23239c0b554ffb17784
  isValidKnightMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidKnightMovement ww1 ww4 ww6 ww9 } } } }) -}
f7cfd91e42b16a307b7e3dfe20ff02ac
  isValidMove ::
    GHC.Maybe.Maybe ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U><L,1*U(U(U),U(U))><L,1*U(U(U),U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Maybe.Maybe ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case ChessBoard.$wisValidMove w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
2535f5ff65294055040c94a4b8bdfc1d
  isValidMoveColor ::
    ChessBoard.Color
    -> GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (ds1 :: ChessBoard.Color)
                   (ds2 :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds2 of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just ipv
                   -> case ds1 of wild1 {
                        ChessBoard.Black
                        -> case ipv of wild2 { ChessBoard.Piece ds3 ds4 ->
                           case ds3 of wild3 {
                             ChessBoard.Black -> GHC.Types.True
                             ChessBoard.White -> GHC.Types.False } }
                        ChessBoard.White
                        -> case ipv of wild2 { ChessBoard.Piece ds3 ds4 ->
                           case ds3 of wild3 {
                             ChessBoard.Black -> GHC.Types.False
                             ChessBoard.White -> GHC.Types.True } } } }) -}
6e030d1955cac61eb027660332fa2c9d
  isValidMovement ::
    ChessBoard.Piece
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LS),1*U(U,1*U)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 ChessBoard.$wisValidMovement ww1 ww2 ww4 ww7 ww9 ww12 } } } } }) -}
0332738b271ae41cfc94514ad0683398
  isValidMovementPiece ::
    ChessBoard.Piece
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,1*U)><S(S(S)L),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w2 of ww5 { ChessBoard.Location ww6 ww7 ->
                 ChessBoard.$wisValidMovementPiece w ww4 ww2 ww6 ww7 } } }) -}
60b90de85588bb58f84dbcee4811f1e4
  isValidPawnAttack ::
    ChessBoard.Color
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U><S(S(S)L),1*U(1*U(U),U(U))><S(S(S)L),1*U(1*U(U),U(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Color)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w2 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidPawnAttack w ww4 ww2 ww9 ww7 w3 } } } }) -}
7f571bea6cb5e1cfd70e489c3b5fda74
  isValidPawnMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(U,A)><S(S(S)L),1*U(1*U(U),U(U))><S(S(S)L),1*U(1*U(U),U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww9 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidPawnAttack
                        ww1
                        ww7
                        ww5
                        ww12
                        ww10
                        w3 of wild {
                   GHC.Types.False
                   -> case ww5 of ww13 { GHC.Types.I# ww14 ->
                      case ww10 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisValidPawnMovement
                             ww1
                             ww7
                             ww14
                             ww12
                             ww16 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidPawnMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww16)
                                  ww12 of wild2 {
                             GHC.Maybe.Nothing
                             -> case ChessBoard.$wisClearPath ww7 ww14 ww12 ww16 w3 of wild3 {
                                  GHC.Types.False
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                                  GHC.Types.True
                                  -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String) }
                             GHC.Maybe.Just a1
                             -> (GHC.Types.False, ChessBoard.isValidPawnMove1) } } } }
                   GHC.Types.True
                   -> (GHC.Types.True,
                       GHC.Maybe.Nothing @ GHC.Base.String) } } } } } }) -}
140cd16bd3073140d24967323eef5403
  isValidPawnMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPawnMove2) -}
07a29e2113a7167b0b7f84f4ade686cf
  isValidPawnMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPawnMove3) -}
c1c05996bdb88a375c2610a94003aaa9
  isValidPawnMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Location is not open!"#) -}
7a20eb28e0a13a28ee51e8c7efb43baa
  isValidPawnMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPawnMove5) -}
7ca756ab78df4f8dc26f2af1bbd5cea5
  isValidPawnMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPawnMove6) -}
3c256e57ba35df0b6a95ec307798e863
  isValidPawnMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid pawn movement!"#) -}
59a337e0ebfd0650f9c911fde685320c
  isValidPawnMovement ::
    ChessBoard.Color
    -> ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Color)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w2 of ww7 { ChessBoard.Location ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 ChessBoard.$wisValidPawnMovement
                   w
                   ww4
                   ww6
                   ww11
                   ww13 } } } } } }) -}
a216f2c1a3874d227ef0bd318e2db373
  isValidPlayerMove ::
    ChessBoard.Game
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(U,A,A)><S(S(S)L),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Color) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w2 of ww9 { ChessBoard.Location ww10 ww11 ->
                 case ChessBoard.$wisValidPlayerMove
                        ww1
                        ww8
                        ww6
                        ww10
                        ww11
                        w3 of ww12 { (#,#) ww13 ww14 ->
                 (ww13, ww14) } } } } }) -}
2f6d4fe241a13f78d2cc115de3ac034f
  isValidPlayerMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove2) -}
5e1309924ce9a71fdaf0dbf198293e09
  isValidPlayerMove10 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove11) -}
237724a4220f363d3587c7b8c6ac45fa
  isValidPlayerMove11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove12) -}
c88e1882a8c6a30bafda00b3d36ee8cb
  isValidPlayerMove12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not your piece!"#) -}
c203c0cc8cc3038f66a1beecf5d1a63a
  isValidPlayerMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove3) -}
435a6edf2aed94ea25ea46d9c91d8081
  isValidPlayerMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid starting position"#) -}
c8f9d15740e4c9255bd649c853de5932
  isValidPlayerMove4 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove5) -}
1520bb50d7c7daac37e5a5920f9ce53b
  isValidPlayerMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove6) -}
26abc1b442d88bae78b804d4c3352807
  isValidPlayerMove6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid ending position"#) -}
ac999bfcd9c1fb60675de761e416ccc6
  isValidPlayerMove7 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidPlayerMove8) -}
84c5b7261e1dd77b01d714e3827ceb69
  isValidPlayerMove8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidPlayerMove9) -}
e75516c341f8a51b87a22876fe58a1b7
  isValidPlayerMove9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Your King is left in Check!"#) -}
47c060d9d86a66949528348bb3f90603
  isValidQueenMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(S(S)S(S)),1*U(U(U),1*U(U))><S(S(S)S(S)),1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidQueenMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidQueenMove1)
                   GHC.Types.True
                   -> case ww4 of ww13 { GHC.Types.I# ww14 ->
                      case ww9 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisClearPath ww14 ww7 ww16 ww12 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww16 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                       ww16 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds1
                                  -> case ds1 of wild4 { ChessBoard.Piece enemyColor ds2 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
5ede98436cdc3a9b68da9e278ac87306
  isValidQueenMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidQueenMove2) -}
10b7c15b2c9533a8129ee8f20bc44997
  isValidQueenMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidQueenMove3) -}
87fabd1ac7997565dec2267d603e83b4
  isValidQueenMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid Queen movement!"#) -}
5dac95d48cd9db5916a7ad30b843295e
  isValidQueenMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(U(U),1*U(U))><S(S(S)S(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidQueenMovement ww1 ww4 ww6 ww9 } } } }) -}
e74a369d996dfb70d5f3d4dc71a49b07
  isValidRookMove ::
    ChessBoard.Piece
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> ChessBoard.Board
    -> (GHC.Types.Bool, GHC.Maybe.Maybe GHC.Base.String)
  {- Arity: 4,
     Strictness: <S,1*U(1*U,A)><S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: ChessBoard.Piece)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location)
                   (w3 :: ChessBoard.Board) ->
                 case w of ww { ChessBoard.Piece ww1 ww2 ->
                 case w1 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case w2 of ww8 { ChessBoard.Location ww9 ww10 ->
                 case ww10 of ww11 { GHC.Types.I# ww12 ->
                 case ChessBoard.$wisValidRookMovement ww4 ww7 ww9 ww12 of wild {
                   GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidRookMove1)
                   GHC.Types.True
                   -> case ww4 of ww13 { GHC.Types.I# ww14 ->
                      case ww9 of ww15 { GHC.Types.I# ww16 ->
                      case ChessBoard.$wisClearPath ww14 ww7 ww16 ww12 w3 of wild1 {
                        GHC.Types.False -> (GHC.Types.False, ChessBoard.isValidBishopMove4)
                        GHC.Types.True
                        -> case GHC.List.$w!!
                                  @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                  (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                  ww16 of wild2 {
                             GHC.Maybe.Nothing
                             -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                             GHC.Maybe.Just a1
                             -> case GHC.List.$w!!
                                       @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                       (GHC.List.$w!! @ ChessBoard.Row w3 ww12)
                                       ww16 of wild3 {
                                  GHC.Maybe.Nothing
                                  -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                  GHC.Maybe.Just ds1
                                  -> case ds1 of wild4 { ChessBoard.Piece enemyColor ds2 ->
                                     case ww1 of wild5 {
                                       ChessBoard.Black
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.False, ChessBoard.isValidBishopMove1)
                                            ChessBoard.White
                                            -> (GHC.Types.True,
                                                GHC.Maybe.Nothing @ GHC.Base.String) }
                                       ChessBoard.White
                                       -> case enemyColor of wild6 {
                                            ChessBoard.Black
                                            -> (GHC.Types.True, GHC.Maybe.Nothing @ GHC.Base.String)
                                            ChessBoard.White
                                            -> (GHC.Types.False,
                                                ChessBoard.isValidBishopMove1) } } } } } } } } } } } } } }) -}
c72160f34fd28329d1b1b2a467a26fa1
  isValidRookMove1 :: GHC.Maybe.Maybe [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Maybe.Just
                   @ [GHC.Types.Char]
                   ChessBoard.isValidRookMove2) -}
efd2894f5ba28bcd962b5734784636d2
  isValidRookMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.isValidRookMove3) -}
0c37c0626835c59346b41bef0672388e
  isValidRookMove3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invalid rook movement!"#) -}
77bbb878e4501e0c26bc791a2a9b8f75
  isValidRookMovement ::
    ChessBoard.Location -> ChessBoard.Location -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(U(U),1*U(U))><S(LS(S)),1*U(U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Location) (w1 :: ChessBoard.Location) ->
                 case w of ww { ChessBoard.Location ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { ChessBoard.Location ww6 ww7 ->
                 case ww7 of ww8 { GHC.Types.I# ww9 ->
                 ChessBoard.$wisValidRookMovement ww1 ww4 ww6 ww9 } } } }) -}
50f9d1f952425353c184bf236b72842a
  location ::
    ChessBoard.ColLoc -> ChessBoard.RowLoc -> ChessBoard.Location
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True) ChessBoard.Location -}
09386c93f54b83194750c89cc3b8d45d
  mkDiagLocs ::
    [GHC.Types.Int] -> [GHC.Types.Int] -> [ChessBoard.Location]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
c15bf550a2ce866bbcf61b4b43c9e2d8
  movePiece ::
    ChessBoard.Board
    -> ChessBoard.Location -> ChessBoard.Location -> ChessBoard.Board
  {- Arity: 3,
     Strictness: <L,U><S,1*U(U(U),U(U))><S(LS(S)),1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w1 of ww { ChessBoard.Location ww1 ww2 ->
                 case w2 of ww3 { ChessBoard.Location ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 ChessBoard.$wmovePiece w ww1 ww2 ww4 ww7 } } }) -}
0c8660847805700d74fd94c21ab37e42
  name :: ChessBoard.Player -> GHC.Base.String
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLLL),1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Player) ->
                 case ds1 of wild { ChessBoard.Player ds2 ds3 ds4 ds5 ds6 ->
                 ds2 }) -}
a003141ffd1ee0d819a8c3b55df32c5a
  notColor :: ChessBoard.Color -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Color) ->
                 case ds1 of wild {
                   ChessBoard.Black -> ChessBoard.White
                   ChessBoard.White -> ChessBoard.Black }) -}
ef719fa270d797e225e6df1e0141b108
  pawnRow :: [ChessBoard.ChessPiece]
  {- Unfolding: (case ChessBoard.$wxs2 8# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ ChessBoard.ChessPiece ww1 ww2 }) -}
d8c7920426b48b587948e345293cbcf9
  pieceValue :: ChessBoard.ChessPiece -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.ChessPiece) ->
                 case ds1 of wild {
                   ChessBoard.Pawn -> ChessBoard.pieceValue5
                   ChessBoard.Bishop -> ChessBoard.pieceValue4
                   ChessBoard.Knight -> ChessBoard.pieceValue4
                   ChessBoard.Rook -> ChessBoard.pieceValue3
                   ChessBoard.Queen -> ChessBoard.pieceValue2
                   ChessBoard.King -> ChessBoard.pieceValue1 }) -}
79b1dd6b134131fdd0311d520fce12c4
  pieceValue1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 10#) -}
4325ea528983c89cfb18218239e0131a
  pieceValue2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 9#) -}
dc8332798325262e5645227b80717b58
  pieceValue3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5#) -}
f0d0131a6da1fa43ea926a5aebbc8e86
  pieceValue4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
377d08f0edbd5acb11d087de03caff35
  pieceValue5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
0c8660847805700d74fd94c21ab37e42
  playerColor :: ChessBoard.Player -> ChessBoard.Color
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Player) ->
                 case ds1 of wild { ChessBoard.Player ds2 ds3 ds4 ds5 ds6 ->
                 ds3 }) -}
a2a68efcecfad83c26ec5cf9dc7447ec
  printBoard :: ChessBoard.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (board :: ChessBoard.Board) ->
                 GHC.CString.unpackAppendCString#
                   ChessBoard.printBoard4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ChessBoard.rowSep
                      (letrec {
                         go1 :: GHC.Prim.Int# -> [GHC.Base.String]
                           {- Arity: 1, Strictness: <L,U> -}
                         = \ (x2 :: GHC.Prim.Int#) ->
                           GHC.Types.:
                             @ GHC.Base.String
                             (case ChessBoard.$wprintRow x2 board of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ GHC.Types.Char ww1 ww2 })
                             (case x2 of wild {
                                DEFAULT -> go1 (GHC.Prim.+# wild 1#)
                                7# -> GHC.Types.[] @ GHC.Base.String })
                       } in
                       case go1 0# of wild {
                         [] -> ChessBoard.rowSep
                         : x2 xs
                         -> ChessBoard.printBoard_go
                              (GHC.Types.:
                                 @ GHC.Base.String
                                 x2
                                 (Data.OldList.prependToAll
                                    @ GHC.Base.String
                                    ChessBoard.rowSep
                                    xs)) }))) -}
3e29641befad27edc4aba0e4497c1bf8
  printBoard1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.printBoard2) -}
66442d5acda6985b9e6c66336c147c95
  printBoard2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("|\n"#) -}
411f6e5f17b366941b0357b81c40d3d9
  printBoard3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" |"#) -}
6e8fd4ae12678123017f854f4fe77527
  printBoard4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("   A  B  C  D  E  F  G  H  \n"#) -}
55b2193e453f49a665b2a8672daf1a94
  printBoard_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
601958c93246d2d8fde1b3e438010f76
  printBoard_go1 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
e5ce9d43eb1e4adb5c817e877c0b7341
  printCol :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> ChessBoard.$wprintCol ww1 }) -}
c701cd6fbf38cb56007039a9dc47ef1a
  printMaybePiece ::
    GHC.Maybe.Maybe ChessBoard.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: GHC.Maybe.Maybe ChessBoard.Piece) ->
                 case ds1 of wild {
                   GHC.Maybe.Nothing -> ChessBoard.printMaybePiece1
                   GHC.Maybe.Just ds2
                   -> case ds2 of wild1 { ChessBoard.Piece c cp ->
                      ChessBoard.printPiece c cp } }) -}
cc951904d4237b23b88e9bc9ae4c214b
  printMaybePiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.printMaybePiece2) -}
6410c85e180d5fc8f4bbdae6d2b0c00d
  printMaybePiece2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  "#) -}
f411a714240d133d60621ee4eaf604cc
  printPiece ::
    ChessBoard.Color -> ChessBoard.ChessPiece -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (c :: ChessBoard.Color)
                   (cp :: ChessBoard.ChessPiece) ->
                 case c of wild {
                   ChessBoard.Black
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowChessPiece9
                        (case cp of wild1 {
                           ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                           ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                           ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                           ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                           ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                           ChessBoard.King -> ChessBoard.$fShowChessPiece1 })
                   ChessBoard.White
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ChessBoard.$fShowColor2
                        (case cp of wild1 {
                           ChessBoard.Pawn -> ChessBoard.$fShowChessPiece11
                           ChessBoard.Bishop -> ChessBoard.$fShowChessPiece9
                           ChessBoard.Knight -> ChessBoard.$fShowChessPiece7
                           ChessBoard.Rook -> ChessBoard.$fShowChessPiece5
                           ChessBoard.Queen -> ChessBoard.$fShowChessPiece3
                           ChessBoard.King -> ChessBoard.$fShowChessPiece1 }) }) -}
b7159437b005499b8350310aab1716fe
  printPlayerScore :: ChessBoard.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,A,A,1*U(U))>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Player) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 ChessBoard.$wprintPlayerScore ww1 ww2 ww5 }) -}
6a3b8df024d486ee7274504b511d6950
  printPlayerScore1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" has score: "#) -}
e0da6234180f99ce79bce1cdf91e55df
  printPlayerScore2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" using "#) -}
1467be29efa34506c661b9f158665bb7
  printPlayerScore3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player "#) -}
91b048d466f837b0e36f91cd3e21a5ce
  printRow ::
    ChessBoard.RowLoc -> ChessBoard.Board -> GHC.Base.String
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U>m2, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.RowLoc) (w1 :: ChessBoard.Board) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case ChessBoard.$wprintRow ww1 w1 of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ GHC.Types.Char ww3 ww4 } }) -}
4e677d07bebcf7e0e3d912eff70a1296
  printScore :: ChessBoard.Game -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S(LSL),1*U(A,1*U(1*U,1*U,A,A,1*U(U)),1*U(1*U,1*U,A,A,1*U(U)))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ChessBoard.Game) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case ww2 of ww4 { ChessBoard.Player ww5 ww6 ww7 ww8 ww9 ->
                 ChessBoard.$wprintScore ww5 ww6 ww9 ww3 } }) -}
66c97400b77b3b20c5afbb463e148830
  printScore1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
01b20d1a25e9b44ac51326028fe120ff
  promotePawn ::
    ChessBoard.Game
    -> ChessBoard.Location -> ChessBoard.ChessPiece -> ChessBoard.Game
  {- Arity: 3, Strictness: <S,1*U(U,U,U)><S,1*U(U(U),1*U(U))><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Game)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.ChessPiece) ->
                 case w of ww { ChessBoard.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { ChessBoard.Location ww5 ww6 ->
                 ChessBoard.Game
                   (case ww6 of ww7 { GHC.Types.I# ww8 ->
                    ChessBoard.$wchangeBoard
                      ww1
                      (GHC.Maybe.Just
                         @ ChessBoard.Piece
                         (ChessBoard.Piece
                            (case ww5 of ww9 { GHC.Types.I# ww10 ->
                             case GHC.List.$w!!
                                    @ (GHC.Maybe.Maybe ChessBoard.Piece)
                                    (GHC.List.$w!! @ ChessBoard.Row ww1 ww8)
                                    ww10 of wild {
                               GHC.Maybe.Nothing
                               -> case Data.Maybe.fromJust1 ret_ty ChessBoard.Color of {}
                               GHC.Maybe.Just x2
                               -> case x2 of wild1 { ChessBoard.Piece color ds1 -> color } } })
                            w2))
                      ww5
                      ww8 })
                   ww2
                   ww3 } }) -}
792ed9cf7fb31cc134c6e147d5735a3b
  promotePawnBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Color
    -> ChessBoard.ChessPiece
    -> ChessBoard.Board
  {- Arity: 4,
     Strictness: <L,U><S(LS(S)),1*U(1*U(U),1*U(U))><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (board :: ChessBoard.Board)
                   (ds1 :: ChessBoard.Location)
                   (color :: ChessBoard.Color)
                   (cp :: ChessBoard.ChessPiece) ->
                 case ds1 of wild { ChessBoard.Location col row ->
                 ChessBoard.changeBoard
                   board
                   (GHC.Maybe.Just @ ChessBoard.Piece (ChessBoard.Piece color cp))
                   col
                   row }) -}
9d8234e2ed17769d45ae731c496ea727
  removePiece ::
    [ChessBoard.ChessPiece]
    -> GHC.Maybe.Maybe GHC.Types.Int -> [ChessBoard.ChessPiece]
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (listPieces :: [ChessBoard.ChessPiece])
                   (index :: GHC.Maybe.Maybe GHC.Types.Int) ->
                 case index of wild {
                   GHC.Maybe.Nothing -> listPieces
                   GHC.Maybe.Just a1
                   -> case a1 of wild1 { GHC.Types.I# x2 ->
                      case GHC.Prim.<=# x2 0# of lwild {
                        DEFAULT
                        -> case listPieces of wild2 {
                             [] -> ChessBoard.removePiece1
                             : ipv ipv1
                             -> case x2 of ds1 {
                                  DEFAULT
                                  -> let {
                                       ds2 :: ([ChessBoard.ChessPiece], [ChessBoard.ChessPiece])
                                       = case GHC.List.splitAt_$s$wsplitAt'
                                                @ ChessBoard.ChessPiece
                                                ipv1
                                                (GHC.Prim.-# ds1 1#) of ww { (#,#) ww1 ww2 ->
                                         (ww1, ww2) }
                                     } in
                                     GHC.Base.++_$s++
                                       @ ChessBoard.ChessPiece
                                       (case ds2 of wild3 { (,) xs' xs'' ->
                                        case xs'' of wild4 {
                                          [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                          : ds4 xs -> xs } })
                                       ipv
                                       (case ds2 of wild3 { (,) xs' xs'' -> xs' })
                                  1#
                                  -> GHC.Base.++_$s++
                                       @ ChessBoard.ChessPiece
                                       (case ipv1 of wild3 {
                                          [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                          : ds2 xs -> xs })
                                       ipv
                                       (GHC.Types.[] @ ChessBoard.ChessPiece) } }
                        1#
                        -> GHC.Base.++
                             @ ChessBoard.ChessPiece
                             (GHC.Types.[] @ ChessBoard.ChessPiece)
                             (case listPieces of wild2 {
                                [] -> GHC.List.scanl2 @ ChessBoard.ChessPiece
                                : ds1 xs -> xs }) } } }) -}
5ee1dffd29832597f448ba2536ff4ac1
  removePiece1 :: [ChessBoard.ChessPiece]
  {- Unfolding: (GHC.Base.++
                   @ ChessBoard.ChessPiece
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   (GHC.List.scanl2 @ ChessBoard.ChessPiece)) -}
60c025530bcbcd80596bae71478ba43c
  rowSep :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   ChessBoard.printMaybePiece2
                   ChessBoard.rowSep1) -}
63578eb5be6cb2b7a1b2ddeaa3701ae5
  rowSep1 :: [GHC.Types.Char]
  {- Unfolding: (ChessBoard.$wxs3 8#) -}
0c8660847805700d74fd94c21ab37e42
  score :: ChessBoard.Player -> GHC.Types.Int
  RecSel Left ChessBoard.Player
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLS),1*U(A,A,A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Player) ->
                 case ds1 of wild { ChessBoard.Player ds2 ds3 ds4 ds5 ds6 ->
                 ds6 }) -}
855ae84d6e3c6bf6270cc556a0f4177a
  startBoard :: ChessBoard.Board
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard13
                   ChessBoard.startBoard1) -}
379aaa304bd5ca505ada37a8eb234c29
  startBoard1 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard11
                   ChessBoard.startBoard2) -}
dff44fd341e79d63b7db45d236b5bc51
  startBoard10 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard9
                   ChessBoard.pawnRow) -}
4ca5c662393503da7dd54b1bd45889c7
  startBoard11 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard12
                   ChessBoard.pawnRow) -}
b76e2424b613ab0908f56193c8e73781
  startBoard12 ::
    ChessBoard.ChessPiece -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: (\ (x2 :: ChessBoard.ChessPiece) ->
                 GHC.Maybe.Just
                   @ ChessBoard.Piece
                   (ChessBoard.Piece ChessBoard.White x2)) -}
433964dc1d5420168e302125e040b62a
  startBoard13 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard12
                   ChessBoard.baseRow) -}
08e14d83d8ad1a95c94245d4ced81e5a
  startBoard2 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard3) -}
0a729c06e5bd69b96193f56b9da10eea
  startBoard3 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard4) -}
feb091cc3729e01a89c9a56ec40411bb
  startBoard4 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard5) -}
889affdb78bbf4ef19ae24e1f7112232
  startBoard5 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.emptyRow
                   ChessBoard.startBoard6) -}
063ffc361bc05559c188d1d407cd118c
  startBoard6 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard10
                   ChessBoard.startBoard7) -}
384c17b048914ffa6c9e9bd9ae07b24d
  startBoard7 :: [ChessBoard.Row]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ChessBoard.Row
                   ChessBoard.startBoard8
                   (GHC.Types.[] @ ChessBoard.Row)) -}
02c8d5d1cafef90ed0ed89223bb20078
  startBoard8 :: [GHC.Maybe.Maybe ChessBoard.Piece]
  {- Unfolding: (GHC.Base.map
                   @ ChessBoard.ChessPiece
                   @ (GHC.Maybe.Maybe ChessBoard.Piece)
                   ChessBoard.startBoard9
                   ChessBoard.baseRow) -}
e829a9ac948d347e77b9103d5c525d30
  startBoard9 ::
    ChessBoard.ChessPiece -> GHC.Maybe.Maybe ChessBoard.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: (\ (x2 :: ChessBoard.ChessPiece) ->
                 GHC.Maybe.Just
                   @ ChessBoard.Piece
                   (ChessBoard.Piece ChessBoard.Black x2)) -}
15d15149e2c1d0ebbdf88a3538cf910d
  swapLoc :: ChessBoard.Location -> ChessBoard.Location
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: ChessBoard.Location) ->
                 case ds1 of wild { ChessBoard.Location col row ->
                 ChessBoard.Location row col }) -}
9acd37a1208b6cb0b923758d053b1530
  turnToColor :: GHC.Types.Int -> ChessBoard.Color
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: GHC.Types.Int) ->
                 case ds1 of wild { GHC.Types.I# ds2 ->
                 case ds2 of ds3 {
                   DEFAULT -> ChessBoard.Black 1# -> ChessBoard.White } }) -}
715d7b2b85ae237ca3ec43a6f41679dc
  updateActive ::
    ChessBoard.Player -> ChessBoard.ChessPiece -> ChessBoard.Player
  {- Arity: 2, Strictness: <S,1*U(U,U,U,U,U)><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ChessBoard.Player) (w1 :: ChessBoard.ChessPiece) ->
                 case w of ww { ChessBoard.Player ww1 ww2 ww3 ww4 ww5 ->
                 case ChessBoard.$wupdateActive
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        w1 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 ChessBoard.Player ww7 ww8 ww9 ww10 ww11 } }) -}
a1b87ecb7d2c3b18cfa76cd24afe640d
  updateBoard ::
    ChessBoard.Board
    -> ChessBoard.Location
    -> ChessBoard.Location
    -> (ChessBoard.Board, GHC.Maybe.Maybe ChessBoard.Piece)
  {- Arity: 3,
     Strictness: <S,U><L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: ChessBoard.Board)
                   (w1 :: ChessBoard.Location)
                   (w2 :: ChessBoard.Location) ->
                 case w2 of ww { ChessBoard.Location ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case ChessBoard.$wupdateBoard
                        w
                        w1
                        ww4
                        ww6 of ww7 { (#,#) ww8 ww9 ->
                 (ww8, ww9) } } } }) -}
a89c4acf0164f93cd8c33751efa62cd3
  updateCaptured ::
    ChessBoard.Player -> ChessBoard.ChessPiece -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (cp :: ChessBoard.ChessPiece) ->
                 case p of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ChessBoard.Player
                   ds1
                   ds2
                   (GHC.Types.: @ ChessBoard.ChessPiece cp ds3)
                   ds4
                   ds5 }) -}
d87bbe482ebdd9fa8f04e7c54ac6fba4
  updateGameBoard ::
    ChessBoard.Game -> ChessBoard.Board -> ChessBoard.Game
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (g :: ChessBoard.Game) (b :: ChessBoard.Board) ->
                 case g of wild { ChessBoard.Game ds1 ds2 ds3 ->
                 ChessBoard.Game b ds2 ds3 }) -}
cdc837c4c440d0efcfc9e1c1061c909a
  updateGamePlayers ::
    ChessBoard.Game
    -> ChessBoard.Player -> ChessBoard.Player -> ChessBoard.Game
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U(U,A,A)><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (g :: ChessBoard.Game)
                   (p1 :: ChessBoard.Player)
                   (p2 :: ChessBoard.Player) ->
                 case g of wild { ChessBoard.Game ds1 ds2 ds3 ->
                 ChessBoard.Game ds1 p1 p2 }) -}
f7c64f68f88c66a1b46df2e4a3a8b5b7
  updatePlayerName ::
    ChessBoard.Player -> GHC.Base.String -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U,U,U,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (newname :: GHC.Base.String) ->
                 case p of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ChessBoard.Player newname ds2 ds3 ds4 ds5 }) -}
a5ff1054b310c310bc1920bb6e19c14e
  updateScore ::
    ChessBoard.Player -> GHC.Types.Int -> ChessBoard.Player
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,U,1*U(U))><L,1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: ChessBoard.Player) (int :: GHC.Types.Int) ->
                 case p of wild { ChessBoard.Player ds1 ds2 ds3 ds4 ds5 ->
                 ChessBoard.Player
                   ds1
                   ds2
                   ds3
                   ds4
                   (GHC.Num.$fNumInt_$c+ ds5 int) }) -}
9616d8f7a4a4971dd577fe8568e08537
  whitePlayer :: ChessBoard.Player
  {- Strictness: m,
     Unfolding: (ChessBoard.Player
                   ChessBoard.whitePlayer1
                   ChessBoard.White
                   (GHC.Types.[] @ ChessBoard.ChessPiece)
                   ChessBoard.blackPlayer1
                   ChessBoard.$fShowPlayer2) -}
76ff9c76c0f4eafb4286f8340faa3f3d
  whitePlayer1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ChessBoard.whitePlayer2) -}
d90d4ce7c6cb43cf3f0808a0e098c253
  whitePlayer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Player 1"#) -}
instance [safe] GHC.Classes.Eq [ChessBoard.ChessPiece]
  = ChessBoard.$fEqChessPiece
instance [safe] GHC.Classes.Eq [ChessBoard.Color]
  = ChessBoard.$fEqColor
instance [safe] GHC.Classes.Eq [ChessBoard.Direction]
  = ChessBoard.$fEqDirection
instance [safe] GHC.Classes.Eq [ChessBoard.GameOver]
  = ChessBoard.$fEqGameOver
instance [safe] GHC.Classes.Eq [ChessBoard.Piece]
  = ChessBoard.$fEqPiece
instance [safe] GHC.Show.Show [ChessBoard.ChessPiece]
  = ChessBoard.$fShowChessPiece
instance [safe] GHC.Show.Show [ChessBoard.Color]
  = ChessBoard.$fShowColor
instance [safe] GHC.Show.Show [ChessBoard.GameOver]
  = ChessBoard.$fShowGameOver
instance [safe] GHC.Show.Show [ChessBoard.Location]
  = ChessBoard.$fShowLocation
instance [safe] GHC.Show.Show [ChessBoard.Piece]
  = ChessBoard.$fShowPiece
instance [safe] GHC.Show.Show [ChessBoard.Player]
  = ChessBoard.$fShowPlayer
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

